/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.18 from the
 * contents of GetData.xs. Do not edit this file, edit GetData.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "GetData.xs"
/* Copyright (C) 2011-2017 D. V. Wiebe
 *
 **************************************************************************
 *
 * This file is part of the GetData project.
 *
 * GetData is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * GetData is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GetData; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef _BSD_SOURCE
#undef _POSIX_SOURCE
#undef _SVID_SOURCE
#undef VERSION
#include "internal.h"

#ifdef GETDATA_DEBUG
#include "debug.c"
#endif

/* Perl 5.8.9 and earlier don't provide hv_fetchs */
#ifdef hv_fetchs
# define gdp_hv_fetchs hv_fetchs
#else
# define gdp_hv_fetchs(hv,key,lval) hv_fetch(hv, key, sizeof(key) - 1, lval)
#endif

#define undef &PL_sv_undef

/* fake data types to simplify our typemap */
typedef GD_DCOMPLEXP_t gdp_complex_in;
typedef GD_DCOMPLEXP_t gdp_complex_undef;
typedef GD_DCOMPLEXA(gdp_complex);
typedef int gdp_ffff_t;
typedef int gdp_numbits_t;
typedef gd_int64_t gdp_int64_t;
typedef unsigned int gdp_uint_t;
typedef gd_type_t gdp_type_t;
typedef int gdp_int;
typedef const char gdp_char;
typedef gd_entry_t gdp_pentry_t;

#define GDP_DIRFILE_ALIAS \
  const char *gdp_package = ix ? "GetData::Dirifle" : "GetData";

#define GDP_UNDEF_ON_ERROR(x) \
      if (gd_error(dirfile)) { x; dreturnvoid(); XSRETURN_UNDEF; }

#define GDP_PUSHpvn(s)       PUSHs(sv_2mortal(newSVpvn(s, sizeof(s) - 1)))
#define GDP_PUSHpvz(s)       PUSHs(sv_2mortal(newSVpv(s, 0)))
#define GDP_PUSHuv(s)        PUSHs(sv_2mortal(newSVuv(s)))
#define GDP_PUSHiv(s)        PUSHs(sv_2mortal(newSViv(s)))
#define GDP_PUSHnv(s)        PUSHs(sv_2mortal(newSVnv(s)))
#define GDP_PUSHrv(s)        PUSHs(sv_2mortal(newRV_noinc((SV*)s)))
#define GDP_PUSHcmp(r,i)     PUSHs(sv_2mortal(gdp_newSVcmp(r,i)))
#define GDP_PUSHrvavpv(s,n)  PUSHs(sv_2mortal(gdp_newRVavpv((const char**)s,n)))
#define GDP_PUSHrvavcmp(s,n) PUSHs(sv_2mortal(gdp_newRVavcmp(s,n)))
#define GDP_PUSHrvavnv(s,n)  PUSHs(sv_2mortal(gdp_newRVavnv(s,n)))

struct gdp_callback_stuff_t {
  SV *func;
  SV *data;
};

struct gdp_dirfile_t {
  DIRFILE *D;
  struct gdp_callback_stuff_t cbdata;
};

static DIRFILE *gdp_invalid = NULL;

/* Newx wrapper for the C library to use */
static void *gdp_malloc(size_t n)
{
  void *ptr;
  dtrace("%zu", n);

  Newx(ptr, n, char);

  dreturn("%p", ptr);
  return ptr;
}

/* sv might be NULL, indicating undef */
static gd_type_t gdp_get_type(SV **sv, const char *pkg, const char *func)
{
  dtrace("%p, \"%s\", \"%s\"", sv, pkg, func);

  if (sv == NULL || *sv == undef)
    croak("%s::%s() - Value may not be undef", pkg, func);

  if (sv_isa(*sv, "Math::Complex")) {
    dreturn("%03x", GD_COMPLEX128);
    return GD_COMPLEX128;
  } else if (SvTYPE(*sv) == SVt_IV) {
    dreturn("%03x", GD_INT64);
    return GD_INT64;
  }

  dreturn("%03x", GD_FLOAT64);
  return GD_FLOAT64;
}

/* convert a reference to a list of strings into a const char** */
static const char **gdp_convert_const_avpv(SV *src, size_t *len_out,
  const char *pkg, const char *func)
{
  const char **dst;

  dtrace("%p, %p, \"%s\", \"%s\"", src, len_out, pkg, func);

  if (src == undef) {
    dst = NULL;
    if (len_out)
      *len_out = 0;
  } else if (SvROK(src) && SvTYPE(SvRV(src)) == SVt_PVAV) {
    AV *av = (AV*)SvRV(src);
    I32 i, len = av_len(av);

    Newx(dst, 1 + len, const char*);
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL || SvTYPE(*sv) != SVt_PV) {
        safefree(dst);
        croak("%s::%s() - Expected array of strings", pkg, func);
      }
      dst[i] = SvPV_nolen(*av_fetch(av, i, 0));
    }
    if (len_out)
      *len_out = (size_t)len + 1;
  } else
    croak("%s::%s - Expected array of strings", pkg, func);

  dreturn("%p", dst);
  return dst;
}

/* convert a string list or a reference to a list into a const char ** */
static const char **gdp_convert_strarr(size_t *len_out,  I32 items, I32 ax,
    int offs, const char *pkg, const char *func)
{
  const char **dst;

  dtrace("%p, %i, %i, %i, \"%s\", \"%s\"", len_out, (int)items, (int)ax,
      offs, pkg, func);

  /* if we have more than one data argument, or the first argument is a
   * string, assume it's not a reference */
  if (items - offs > 1 || SvTYPE(ST(offs)) == SVt_PVAV) {
    I32 i, len;
    len = items - offs;
    Newx(dst, items - offs, const char*);
    for (i = 0; i < len; ++i) {
      SV *sv = ST(offs + i);
      if (SvTYPE(sv) != SVt_PV) {
        safefree(dst);
        croak("%s::%s() - Expected array of strings", pkg, func);
      }
      dst[i] = SvPV_nolen(sv);
    }

    if (len_out)
      *len_out = len;
  } else
    dst = gdp_convert_const_avpv(ST(offs), len_out, pkg, func);

  dreturn("%p", dst);
  return dst;
}

/* convert a Perl object into a complex number */
static void gdp_convert_cmp(GD_DCOMPLEXP_t val, SV *src, int *ok,
    const char* pkg, const char *func)
{
  dtrace("%p, %p, %p, \"%s\", \"%s\"", val, src, ok, pkg, func);

  if (sv_isa(src, "Math::Complex")) {
    HV *hv = (HV *)SvRV(src);
    SV **c_dirty = gdp_hv_fetchs(hv, "c_dirty", 0);
    if (c_dirty == NULL)
      croak("%s::%s() - Malformed Math::Complex object", pkg, func);
    if (SvIV(*c_dirty)) {
      SV **sv = gdp_hv_fetchs(hv, "polar", 0);
      if (sv == NULL || !SvROK(*sv) || SvTYPE(SvRV(*sv)) != SVt_PVAV)
        croak("%s::%s() - Malformed Math::Complex object", pkg, func);

      AV *data = (AV*)SvRV(*sv);
      SV **m = av_fetch(data, 0, 0);
      SV **a = av_fetch(data, 1, 0);
      if (m == NULL || a == NULL)
        croak("%s::%s() - Malformed Math::Complex object", pkg, func);
      gd_po2cp_(val, SvNV(*m), SvNV(*a));
    } else {
      SV **sv = gdp_hv_fetchs(hv, "cartesian", 0);
      if (sv == NULL || !SvROK(*sv) || SvTYPE(SvRV(*sv)) != SVt_PVAV)
        croak("%s::%s() - Malformed Math::Complex object", pkg, func);

      AV *data = (AV*)SvRV(*sv);
      SV **r = av_fetch(data, 0, 0);
      SV **i = av_fetch(data, 1, 0);
      if (r == NULL || i == NULL)
        croak("%s::%s() - Malformed Math::Complex object", pkg, func);
      gd_li2cp_(val, SvNV(*r), SvNV(*i));
    }
  } else if (ok) {
    /* if ok is non-NULL, the caller is prepared to handle non-complex data */
    *ok = 0;
  } else {
    gd_rs2cp_(val, SvNV(src));
  }

  dreturn("(%g;%g)", crealp(val), cimagp(val));
}

#define GDP_EHASH_FETCH(part,key) \
  v = gdp_hv_fetchs((HV*)sv, key, 0); \
  if (!part && v == NULL) \
    croak("%s::%s() - Missing required key '" key "' in entry hash", pkg, func)

/* handle both "<foo>" and "c<foo>" names */
#define GDP_EHASH_FETCH_CMP(part,key,member) do { \
    GDP_EHASH_FETCH(1,"c" key); \
    if (v == NULL) GDP_EHASH_FETCH(part,key); \
    if (v) gdp_convert_cmp(gd_csp_(E->member), *v, NULL, pkg, func); \
  } while(0)

#define GDP_EHASH_FETCH_IV(part,key,variable,type) \
  do { GDP_EHASH_FETCH(part,key); if (v) variable = (type)SvIV(*v); } while(0)

#define GDP_EHASH_FETCH_NV(part,key,member) \
  do { GDP_EHASH_FETCH(part,key); if (v) E->member = SvNV(*v); } while(0)

#define GDP_EHASH_FETCH_UV(part,key,member,type) \
  do { GDP_EHASH_FETCH(part,key); if (v) E->member = (type)SvUV(*v); } while(0)

#define GDP_EHASH_FETCH_PV(part,key,member) \
 do { \
    GDP_EHASH_FETCH(part,key); \
    if (v) E->member = (!SvOK(*v)) ? NULL : SvPV_nolen(*v); \
  } while(0)

/* populate a complex double array in gd_entry_t */
static int gdp_fetch_cmp_list(GD_DCOMPLEXV(c), HV *hv, int partial, char key,
    int min, int max, unsigned mask, const char *pkg, const char *func)
{
  dtrace("%p, %p, %i, '%c', %i, %i, 0x%X, \"%s\", \"%s\"", c, hv, partial, key,
      min, max, mask, pkg, func);

  int i, n = 0;
  char ckey[3] = { 'c', key, 0 };
  int have[GD_MAX_POLYORD + 1];
  SV **v, *sv = NULL;

  /* try without the 'c' prefix */
  v = hv_fetch(hv, ckey + 1, 1, 0);

  /* try with the 'c' prefix */
  if (v == NULL)
    v = hv_fetch(hv, ckey, 2, 0);

  /* de-reference as needed */
  if (v) {
    sv = *v;
    while (SvROK(sv))
      sv = SvRV(sv);
  }

  if (sv == NULL || SvTYPE(sv) == SVt_NULL) {
    if (partial) {
      dreturn("%i", 0);
      return 0;
    }

    croak("%s::%s() - Missing required key '%c' in entry hash", pkg, func,
        key);
  }

  Zero(have, GD_MAX_POLYORD + 1, int);
  for (i = 0; i < max; ++i)
    if (mask & (1 << i))
      have[i] = 1;

  if (SvTYPE(sv) != SVt_PVAV)
    croak("%s::%s() - Key '%c' must be list in entry hash (%i)", pkg, func, key,
    SvTYPE(sv));

  for (i = 0; i < GD_MAX_LINCOM; ++i)
    if (!have[i]) {
      v = av_fetch((AV*)sv, i, 0);
      if (v) {
        if (i < max)
          gdp_convert_cmp(gd_cap_(c,i), *v, NULL, pkg, func);
        have[i] = 1;
      }
    }

  /* find n */
  for (i = 0; i < GD_MAX_POLYORD + 1; ++i)
    if (i >= n && have[n])
      n = i + 1;

  if (n < min || n > max)
    croak("%s::%s() - Bad array length (%i) for key '%c' in entry hash", pkg,
        func, n, key);

  dreturn("%i", n);
  return n;
}

/* populate in_fields in gd_entry_t */
static int gdp_fetch_in_fields(char **in_fields, SV *sv, int partial, int min,
    int max, const char *pkg, const char *func)
{
  dtrace("%p, %p, %i, %i, %i, \"%s\", \"%s\"", in_fields, sv, partial, min, max,
      pkg, func);

  int i, n = 0;
  SV **v, *vv;

  GDP_EHASH_FETCH(partial, "in_fields");
  if (partial && !v) {
    dreturn("%i", 0);
    return 0;
  }

  /* de-reference as needed */
  vv = *v;
  while (SvROK(vv))
    vv = SvRV(vv);

  if (SvTYPE(vv) == SVt_NULL) { /* undef */
    dreturn("%i", 0);
    return 0;
  }

  if (SvTYPE(vv) != SVt_PVAV) {
    if (SvOK(vv)) {
      n = 1;
      in_fields[0] = SvPV_nolen(vv);
    } else
      croak("%s::%s() - Key 'in_fields' must be list or string in entry hash",
          pkg, func);
  } else {
    int have[GD_MAX_LINCOM * 2];

    Zero(have, GD_MAX_LINCOM * 2, int);

    for (i = 0; i < GD_MAX_LINCOM; ++i) {
      v = av_fetch((AV*)vv, i, 0);
      if (v) {
        if (i < max)
          in_fields[i] = SvPV_nolen(*v);
        have[i] = 1;
      }
    }

    /* find n */
    for (i = 0; i < GD_MAX_LINCOM; ++i)
      if (i >= n && have[n])
        n = i + 1;
  }

  if (n < min || n > max) {
    croak("%s::%s() - Bad array length (%i) for key 'in_fields' in entry hash",
        pkg, func, n);
  }

  dreturn("%i", n);
  return n;
}

/* populate scalar elements of gd_entry_t */
static unsigned gdp_fetch_scalars(gd_entry_t *E, HV *hv, unsigned int mask,
  const char *pkg, const char* func)
{
  dtrace("%p, %p, %06x \"%s\", \"%s\"", E, hv, mask, pkg, func);
  int i;
  unsigned mask_out = 0;

  SV *scalar, *scalar_ind = NULL;
  SV **v = gdp_hv_fetchs(hv, "scalar", 0);

  /* there's no point in recording scalar indicies if we don't have scalars */
  if (v == NULL) {
    dreturn("%i", 0);
    return 0;
  }

  scalar = *v;
  while (SvROK(scalar))
    scalar = SvRV(scalar);

  if (SvTYPE(scalar) == SVt_NULL) { /* drop undef */
    dreturn("%i", 0);
    return 0;
  }

  v = gdp_hv_fetchs(hv, "scalar_ind", 0);
  if (v) {
    scalar_ind = *v;
    while ((SvTYPE(scalar_ind) != SVt_NULL) && SvROK(scalar_ind))
      scalar_ind = SvRV(scalar_ind);

    if (SvTYPE(scalar_ind) == SVt_NULL)
      scalar_ind = NULL;
  }

  if (SvTYPE(scalar) != SVt_PVAV)
    croak("%s::%s() - Key 'scalar' must be list in entry hash", pkg, func);
  if (scalar_ind && SvTYPE(scalar_ind) != SVt_PVAV)
    croak("%s::%s() - Key 'scalar_ind' must be list in entry hash", pkg, func);

  for (i = 0; i <= GD_MAX_POLYORD; ++i)
    if (mask & (1 << i)) {
      v = av_fetch((AV*)scalar, i, 0);
      if (v == NULL || SvTYPE(*v) == SVt_NULL)
        E->scalar[i] = NULL; /* skip */
      else {
        E->scalar[i] = SvPV_nolen(*v);
        mask_out |= (1 << i);
        if (scalar_ind) {
          v = av_fetch((AV*)scalar_ind, i, 0);
          if (v && SvTYPE(*v) != SVt_NULL)
            E->scalar_ind[i] = SvIV(*v);
          else
            E->scalar_ind[i] = 0;
        } else
          E->scalar_ind[i] = 0;
      }
    }

  dreturn("%u", mask_out);
  return mask_out;
}

/* convert a Perl hash into a gd_entry_t */
static void gdp_to_entry(gd_entry_t *E, SV *sv, const gd_entry_t *old_E,
    const char *pkg, const char *func)
{
  dtrace("%p, %p, %p, \"%s\", \"%s\"", E, sv, old_E, pkg, func);
  SV **v;
  int n, min, max;
  unsigned mask, tmask;
  const int partial = (old_E != NULL);

  if (partial)
    StructCopy(old_E, E, gd_entry_t);
  else
    Zero(E, 1, gd_entry_t);

  /* de-reference as needed */
  while (SvROK(sv))
    sv = SvRV(sv);

  if (SvTYPE(sv) != SVt_PVHV)
    croak("%s::%s() - Entry must be hash", pkg, func);

  GDP_EHASH_FETCH_UV(0, "field_type", field_type, gd_entype_t);
  GDP_EHASH_FETCH_PV(partial, "field", field);
  GDP_EHASH_FETCH_UV(partial, "fragment_index", fragment_index, int);

  switch (E->field_type) {
    case GD_BIT_ENTRY:
    case GD_SBIT_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 1, 1, pkg, func);

      mask = gdp_fetch_scalars(E, (HV*)sv, 0x3, pkg, func);

      if (!(mask & 1))
        GDP_EHASH_FETCH_UV(partial, "bitnum", EN(bit,bitnum), int);

      if (!(mask & 2)) {
        GDP_EHASH_FETCH_UV(1, "numbits", EN(bit,numbits), int);
        if (v == NULL)
          if (!partial)
            E->EN(bit,numbits) = 1;
      }

      break;
    case GD_SARRAY_ENTRY:
      GDP_EHASH_FETCH_UV(partial, "array_len", EN(scalar,array_len), size_t);
      break;
    case GD_CARRAY_ENTRY:
      GDP_EHASH_FETCH_UV(partial, "array_len", EN(scalar,array_len), size_t);
      /* fallthrough */
    case GD_CONST_ENTRY:
      GDP_EHASH_FETCH_UV(partial, "const_type", EN(scalar,const_type),
          gd_type_t);
      break;
    case GD_LINCOM_ENTRY:
      GDP_EHASH_FETCH_IV(1, "n_fields", n, int);
      if (v) {
        if (n > GD_MAX_LINCOM || n < 1)
          croak("%s::%s() - n_fields out of range", pkg, func);

        min = max = n;
      } else {
        min = 1;
        max = GD_MAX_LINCOM;
      }

      E->EN(lincom,n_fields) = gdp_fetch_in_fields(E->in_fields, sv, partial,
          min, max, pkg, func);

      if (E->EN(lincom,n_fields) != 0)
        min = max = E->EN(lincom,n_fields);

      E->flags |= GD_EN_COMPSCAL;
      tmask = (1 << max) - 1;

      mask = gdp_fetch_scalars(E, (HV*)sv, ((1 << max) - 1) * 9, pkg, func);

      if ((mask & tmask) != tmask) {
        E->EN(lincom,n_fields) = gdp_fetch_cmp_list(E->EN(lincom,cm), (HV*)sv,
            partial, 'm', min, max, mask, pkg, func);

        if (E->EN(lincom,n_fields) != 0)
          min = max = E->EN(lincom,n_fields);
      }

      if (((mask >> GD_MAX_LINCOM) & tmask) != tmask)
        E->EN(lincom,n_fields) = gdp_fetch_cmp_list(E->EN(lincom,cb), (HV*)sv,
            partial, 'b', min, max, mask >> GD_MAX_LINCOM, pkg, func);
      else
        E->EN(lincom,n_fields) = max;
      break;
    case GD_LINTERP_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 1, 1, pkg, func);
      GDP_EHASH_FETCH_PV(partial, "table", EN(linterp,table));
      break;
    case GD_MULTIPLY_ENTRY:
    case GD_DIVIDE_ENTRY:
    case GD_INDIR_ENTRY:
    case GD_SINDIR_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 2, 2, pkg, func);
      break;
    case GD_PHASE_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 1, 1, pkg, func);

      mask = gdp_fetch_scalars(E, (HV*)sv, 1, pkg, func);

      if (!(mask & 1))
        GDP_EHASH_FETCH_IV(partial, "shift", E->EN(phase,shift), gd_int64_t);
      break;
    case GD_POLYNOM_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 1, 1, pkg, func);

      GDP_EHASH_FETCH_IV(1, "poly_ord", n, int);
      if (v) {
        if (n > GD_MAX_POLYORD || n < 1)
          croak("%s::%s() - poly_ord out of range", pkg, func);

        min = max = n + 1;
      } else {
        min = 2;
        max = GD_MAX_POLYORD + 1;
      }

      mask = gdp_fetch_scalars(E, (HV*)sv, (1 << (max + 1)) - 1, pkg, func);
      tmask = (1 << max) - 1;

      E->flags |= GD_EN_COMPSCAL;
      if ((mask & tmask) != tmask)
        E->EN(polynom,poly_ord) = gdp_fetch_cmp_list(E->EN(polynom,ca), (HV*)sv,
            partial, 'a', min, max, mask, pkg, func) - 1;
      else
        E->EN(polynom,poly_ord) = max - 1;
      break;
    case GD_RECIP_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 1, 1, pkg, func);
      mask = gdp_fetch_scalars(E, (HV*)sv, 1, pkg, func);

      E->flags |= GD_EN_COMPSCAL;
      if (!(mask & 1))
        GDP_EHASH_FETCH_CMP(partial, "dividend", EN(recip,cdividend));
      break;
    case GD_WINDOW_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 2, 2, pkg, func);
      GDP_EHASH_FETCH_IV(partial, "windop", E->EN(window,windop), gd_windop_t);

      mask = gdp_fetch_scalars(E, (HV*)sv, 1, pkg, func);

      if (!(mask & 1))
        switch(E->EN(window,windop)) {
          case GD_WINDOP_EQ:
          case GD_WINDOP_NE:
            GDP_EHASH_FETCH_IV(partial, "threshold", E->EN(window,threshold).i,
                int64_t);
            break;
          case GD_WINDOP_SET:
          case GD_WINDOP_CLR:
            GDP_EHASH_FETCH_UV(partial, "threshold", EN(window,threshold).u,
                uint64_t);
            break;
          default:
            GDP_EHASH_FETCH_NV(partial, "threshold", EN(window,threshold).r);
            break;
        }
      break;
    case GD_MPLEX_ENTRY:
      gdp_fetch_in_fields(E->in_fields, sv, partial, 2, 2, pkg, func);

      mask = gdp_fetch_scalars(E, (HV*)sv, 0x3, pkg, func);

      if (!(mask & 1))
        GDP_EHASH_FETCH_UV(partial, "count_val", EN(mplex,count_val), int);

      if (!(mask & 2))
        GDP_EHASH_FETCH_UV(1, "period", EN(mplex,period), int);
      break;
    case GD_RAW_ENTRY:
      GDP_EHASH_FETCH_UV(partial, "data_type", EN(raw,data_type), gd_type_t);

      mask = gdp_fetch_scalars(E, (HV*)sv, 1, pkg, func);

      if (!(mask & 1))
        GDP_EHASH_FETCH_UV(partial, "spf", EN(raw,spf), unsigned int);
      break;
    case GD_NO_ENTRY:
    case GD_INDEX_ENTRY:
    case GD_STRING_ENTRY:
      break;
    default:
      croak("%s::%s() - Invalid field type %x in entry hash", pkg, func,
        E->field_type);
  }

  dreturnvoid();
}

/* convert a single perl datum into the desired type */
static void gdp_convert_from_perl(void *dest, SV *src, gd_type_t type,
  const char *pkg, const char *func)
{
  dtrace("%p, %p, %03x, \"%s\", \"%s\"", dest, src, type, pkg, func);
  GD_DCOMPLEXA(c);
  int cmp = 1;

  /* undef results in randomness */
  if (src == NULL) {
    dreturnvoid();
    return;
  }

  /* check for and convert complex data */
  gdp_convert_cmp(gd_csp_(c), src, &cmp, pkg, func);

  switch (type) {
    case GD_UINT8:
      *(uint8_t*)dest = cmp ? (uint8_t)creal(c) : (uint8_t)SvUV(src);
      break;
    case GD_INT8:
      *(int8_t*)dest = cmp ? (int8_t)creal(c) : (int8_t)SvIV(src);
      break;
    case GD_UINT16:
      *(uint16_t*)dest = cmp ? (uint16_t)creal(c) : (uint16_t)SvUV(src);
      break;
    case GD_INT16:
      *(int16_t*)dest = cmp ? (int16_t)creal(c) : (int16_t)SvIV(src);
      break;
    case GD_UINT32:
      *(uint32_t*)dest = cmp ? (uint32_t)creal(c) : (uint32_t)SvUV(src);
      break;
    case GD_INT32:
      *(int32_t*)dest = cmp ? (int32_t)creal(c) : (int32_t)SvIV(src);
      break;
    case GD_UINT64:
      *(uint64_t*)dest = cmp ? (uint64_t)creal(c) : (uint64_t)SvUV(src);
      break;
    case GD_INT64:
      *(int64_t*)dest = cmp ? (int64_t)creal(c) : (int64_t)SvIV(src);
      break;
    case GD_FLOAT32:
      *(float*)dest = cmp ? (float)creal(c) : (float)SvNV(src);
      break;
    case GD_FLOAT64:
      *(double*)dest = cmp ? (double)creal(c) : (double)SvNV(src);
      break;
    case GD_COMPLEX64:
      if (cmp)
        gd_cs2ca_(dest,0,c,float);
      else
        gd_rs2ca_(dest,0,SvNV(src),float);
      break;
    case GD_COMPLEX128:
      if (cmp)
        gd_cs2ca_(dest,0,c,double);
      else
        gd_rs2ca_(dest,0,SvNV(src),double);
      break;
    case GD_NULL:
    case GD_UNKNOWN:
    case GD_STRING:
      ;
  }

  dreturnvoid();
}

struct gdp_din {
  void *data_in;
  gd_type_t type;
  int arg_type;
  size_t nsamp;
};

#define GDP_DATA_IN_LIST 0
#define GDP_DATA_IN_PACK 1
#define GDP_DATA_IN_REF  2
static struct gdp_din gdp_convert_data(SV *d, I32 items, I32 ax, size_t idx,
  const char *pkg, const char *func)
{
  struct gdp_din din = {NULL, GD_NULL, GDP_DATA_IN_PACK, 0};
  size_t i;
  AV *av = NULL;

  dtrace("%p, %i, %i, %" PRIuSIZE ", \"%s\", \"%s\"", d, (int)items, (int)ax,
      idx, pkg, func);

  /* argument grokking goes thus (in order!):
   * if d == undef, the remaining arguments are taken to be data
   * if d == reference to an array, the array is taken to be data, and
   *            remaining arguments ignored
   * if there is exactly one argument after d, d is taken as a type code
   *            and the following argument as either packed data or a
   *            reference to a list.
   * otherwise, d is taken to be the first datum in a list of data.
   */

  if (d == undef) {
    idx++;
    din.arg_type = GDP_DATA_IN_LIST;
  } else if (sv_isa(d, "Math::Complex"))
    din.arg_type = GDP_DATA_IN_LIST;
  else if (SvROK(d)) {
    av = (AV*)SvRV(d);
    din.arg_type = GDP_DATA_IN_REF;
  } else if (items != 6)
    din.arg_type = GDP_DATA_IN_LIST;
  else if (SvROK(ST(5))) {
    av = (AV*)SvRV(ST(5));
    din.arg_type = GDP_DATA_IN_REF;
  }

  if (din.arg_type == GDP_DATA_IN_LIST) {
    din.nsamp = items - idx;
    din.type = gdp_get_type(&ST(idx), pkg, func);
  } else if (din.arg_type == GDP_DATA_IN_REF) {
    if (SvTYPE((SV*)av) != SVt_PVAV)
      croak("%s::%s() - Expected array reference, but found some other "
          "type of object", pkg, func);
    din.nsamp = (size_t)av_len(av) + 1;
    din.type = gdp_get_type(av_fetch(av, 0, 0), pkg, func);
  } else {
    din.type = (gd_type_t)SvIV(d);
    if (GD_SIZE(din.type) == 0)
      croak("%s::%s() - Invalid type code", pkg, func);
    STRLEN n;
    din.data_in = SvPV(ST(5), n);
    din.nsamp = (size_t)n / GD_SIZE(din.type);
  }

  if (din.arg_type != GDP_DATA_IN_PACK)
    Newx(din.data_in, din.nsamp * GD_SIZE(din.type), char);

  if (din.arg_type == GDP_DATA_IN_LIST) {
    for (i = idx; i < items; ++i)
      gdp_convert_from_perl((char*)din.data_in + GD_SIZE(din.type) * (i - idx),
          ST(i), din.type, pkg, func);
  } else if (din.arg_type == GDP_DATA_IN_REF) {
    for (i = 0; i < din.nsamp; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL)
        croak("%s::%s() - Undefined datum encountered", pkg, func);
      gdp_convert_from_perl((char*)din.data_in + GD_SIZE(din.type) * i, *sv,
          din.type, pkg, func);
    }
  }

  dreturn("{ %p, %03x, %i, %" PRIuSIZE " }", din.data_in, din.type,
      din.arg_type, din.nsamp);
  return din;
}

/* convert perl datum (in some sort of format) into an appropriate
 * C datum, with type */
static gd_type_t gdp_to_voidp(void *dest, SV *src, gd_type_t hint,
  const char *pkg, const char *func)
{
  dtrace("%p, %p, %03x, \"%s\", \"%s\"", dest, src, hint, pkg, func);
  gd_type_t type = GD_UNKNOWN;

  /* treat undef as zero */
  if (src == undef) {
    Zero(dest, 1, char);
    type = GD_UINT8;
  } else {
    int cmp = 0;
    GD_DCOMPLEXA(c);
    gdp_convert_cmp(gd_csp_(c), src, &cmp, pkg, func);

    if (cmp) {
      gd_cs2ca_(dest, 0, c, double);
      type = GD_COMPLEX128;
    } else if (SvNOK(src)) {
      *(double*)dest = SvNV(src);
      type = GD_FLOAT64;
    } else if (SvUOK(src)) {
      *(uint64_t*)dest = (uint64_t)SvUV(src);
      type = GD_UINT64;
    } else if (SvIOK(src)) {
      *(int64_t*)dest = (int64_t)SvIV(src);
      type = GD_INT64;
    } else if (hint & GD_COMPLEX || hint & GD_IEEE754) {
      *(double*)dest = SvNV(src);
      type = GD_FLOAT64;
    } else if (hint & GD_SIGNED) {
      *(int64_t*)dest = (int64_t)SvIV(src);
      type = GD_INT64;
    } else {
      *(uint64_t*)dest = (uint64_t)SvUV(src);
      type = GD_UINT64;
    }
  }

  dreturn("%03x", type);
  return type;
}

static SV *gdp_newSVcmp(double r, double i)
{
  SV **dummy;
  SV *sv;
  AV *av;
  HV *hv, *stash;

  dtrace("%g; %g", r, i);

  /* build a list containing the data, and take it's reference */
  av = newAV();
  av_extend(av, 1);
  av_store(av, 0, newSVnv(r));
  av_store(av, 1, newSVnv(i));
  sv = newRV_noinc((SV*)av);

  /* create a Math::Complex object */
  hv = newHV();
  dummy = hv_store(hv, "p_dirty", 7, newSVuv(1), 0);
  dummy = hv_store(hv, "c_dirty", 7, newSVuv(0), 0);
  dummy = hv_store(hv, "cartesian", 9, sv, 0);
  stash = gv_stashpv("Math::Complex", GV_ADD);
  sv = sv_bless(newRV_noinc((SV*)hv), stash);

  dreturn("%p", sv);
  return sv;
}

/* convert a NULL-terminated char ** into a reference to a list of strings */
static SV *gdp_newRVavpv0(const char **l)
{
  dtrace("%p", l);
  SV *rv;
  int i;
  AV *av = newAV();

  for (i = 0; l[i]; ++i)
    av_store(av, i, newSVpv(l[i], 0));

  rv = newRV_noinc((SV*)av);
  dreturn("%p", rv);
  return rv;
}

/* convert a char ** with length into a reference to a list of strings */
static SV *gdp_newRVavpv(const char **l, size_t n)
{
  dtrace("%p, %" PRIuSIZE, l, n);
  SV *rv;
  int i;
  AV *av = newAV();
  av_extend(av, n - 1);

  for (i = 0; i < n; ++i)
    av_store(av, i, newSVpv(l[i], 0));

  rv = newRV_noinc((SV*)av);
  dreturn("%p", rv);
  return rv;
}

/* convert a complex double * into a reference to a list of complex data */
static SV *gdp_newRVavcmp(GD_DCOMPLEXV(l), size_t n)
{
  dtrace("%p, %" PRIuSIZE, l, n);
  SV *rv;
  int i;
  AV *av = newAV();
  av_extend(av, n - 1);

  for (i = 0; i < n; ++i)
    av_store(av, i, gdp_newSVcmp(creal(l[i]), cimag(l[i])));

  rv = newRV_noinc((SV*)av);
  dreturn("%p", rv);
  return rv;
}

/* store some scalar values in the entry hash on the stack from the gd_entry_t
*/
static SV **gdp_store_scalars(SV **sp, const gd_entry_t *E, unsigned int mask)
{
  dtrace("%p, %p, %06x", sp, E, mask);
  int i;

  if (!mask) {
    dreturn("%p", sp);
    return sp;
  }

  AV *scalar = newAV();
  AV *scalar_ind = newAV();
  av_extend(scalar, GD_MAX_POLYORD);
  av_extend(scalar_ind, GD_MAX_POLYORD);
  for (i = 0; i <= GD_MAX_POLYORD; ++i)
    if (mask & (1 << i)) {
      av_store(scalar, i, newSVpv(E->scalar[i], 0));
      if (E->scalar[i] == NULL)
        av_store(scalar_ind, i, undef);
      else
        av_store(scalar_ind, i, newSViv(E->scalar_ind[i]));
    }
  EXTEND(sp, 4);
  GDP_PUSHpvn("scalar");
  GDP_PUSHrv(scalar);
  GDP_PUSHpvn("scalar_ind");
  GDP_PUSHrv(scalar_ind);

  dreturn("%p", sp);
  return sp;
}

/* parser callback wrapper */
static int gdp_parser_callback(gd_parser_data_t *pdata, void *extra)
{
  SV *callback_func = ((struct gdp_callback_stuff_t *)extra)->func;
  SV *callback_data = ((struct gdp_callback_stuff_t *)extra)->data;
  SV *ret, **dummy;
  int n, sem = GD_SYNTAX_ABORT;
  AV *av;
  int len;

  /* local stack pointer */
  dSP;

  dtrace("%p, %p", pdata, extra);

  /* create pseudo-block */
  ENTER;
  SAVETMPS;

  /* create the parser data hash */
  HV *phash = newHV();
  dummy = hv_store(phash, "suberror", 8, newSVuv(pdata->suberror), 0);
  dummy = hv_store(phash, "linenum", 7, newSVuv(pdata->linenum), 0);
  dummy = hv_store(phash, "line", 4, newSVpv(pdata->line, 0), 0);
  dummy = hv_store(phash, "filename", 8, newSVpv(pdata->filename, 0), 0);

  /* create stack frame */
  PUSHMARK(SP);
  EXTEND(SP, 2);

  /* push args */
  PUSHs(sv_2mortal(newRV_noinc((SV *)phash)));
  PUSHs(callback_data);

  /* finalise stack frame */
  PUTBACK;

  /* call the object */
  n = call_sv(callback_func, G_SCALAR);

  /* refresh local stack pointer */
  SPAGAIN;

  /* delete the hash */
  hv_undef(phash);

  /* Make sure we got a scalar back; otherwise complain and abort */
  if (n != 1) {
    croak("GetData: expected scalar response from parser callback.");
    return GD_SYNTAX_ABORT; /* ca'n't get here */
  }

  /* pop our return value */
  ret = POPs;

  /* de-reference as needed */
  while (SvROK(ret)) {
    ret = SvRV(ret);
  }

  /* ferret out response */
  switch (SvTYPE(ret)) {
    case SVt_IV:
      sem = SvIV(ret);
      break;
    case SVt_PVAV:
      av = (AV *)ret;
      len = av_len(av);
      if (len < 0) {
        croak("GetData: parser callback returned empty array.");
        return GD_SYNTAX_ABORT; /* ca'n't get here */
      } else if (len > 1) {
        croak("GetData: too many elements in array returned by parser "
            "callback.");
        return GD_SYNTAX_ABORT; /* ca'n't get here */
      } else if (len == 0) {
        SV **val = av_fetch(av, 0, 0);
        if (val == NULL || SvROK(*val)) {
          croak("GetData: bad data type in array returned by parser callback.");
          return GD_SYNTAX_ABORT; /* ca'n't get here */
        }

        if (SvTYPE(*val) == SVt_IV) {
          sem = SvIV(*val);
        } else if (SvTYPE(*val) == SVt_PV) {
          pdata->line = savepv(SvPV_nolen(*val));
          sem = GD_SYNTAX_RESCAN;
        } else {
          croak("GetData: bad data type in array returned by parser callback.");
          return GD_SYNTAX_ABORT; /* ca'n't get here */
        }
      } else { /* len == 1 */
        SV **val0 = av_fetch(av, 0, 0);
        SV **val1 = av_fetch(av, 1, 0);

        if (val0 == NULL || SvROK(*val0) || val1 == NULL || SvROK(*val1)) {
          croak("GetData: bad data type in array returned by parser callback.");
          return GD_SYNTAX_ABORT; /* ca'n't get here */
        }

        if (SvTYPE(*val0) == SVt_IV && SvTYPE(*val1) == SVt_PV) {
          sem = SvIV(*val0);
          pdata->line = savepv(SvPV_nolen(*val1));
        } else {
          croak("GetData: bad data type in array returned by parser callback.");
          return GD_SYNTAX_ABORT; /* ca'n't get here */
        }
      }
      break;
    case SVt_PV:
    pdata->line = savepv(SvPV_nolen(ret));
    sem = GD_SYNTAX_RESCAN;
    break;
    default:
    croak("GetData: bad data type returned by parser callback.");
    return GD_SYNTAX_ABORT; /* ca'n't get here */
  }

  /* resync global stack pointer */
  PUTBACK;

  /* destroy pseudo-block */
  FREETMPS;
  LEAVE;

  dreturn("%i", sem);
  return sem;
}

#define GDP_UNPACKU(t) \
  if (sp) { \
    EXTEND(sp, n); \
    for (i = 0; i < n; ++i) PUSHs(sv_2mortal(newSVuv(((t*)data)[i]))); \
  } else for (i = 0; i < n; ++i) av_store(av, i,   newSVuv(((t*)data)[i]))

#define GDP_UNPACKI(t) \
  if (sp) { \
    EXTEND(sp, n); \
    for (i = 0; i < n; ++i) PUSHs(sv_2mortal(newSViv(((t*)data)[i]))); \
  } else for (i = 0; i < n; ++i) av_store(av, i,   newSViv(((t*)data)[i]))

#define GDP_UNPACKN(t) \
  if (sp) { \
    EXTEND(sp, n); \
    for (i = 0; i < n; ++i) PUSHs(sv_2mortal(newSVnv(((t*)data)[i]))); \
  } else for (i = 0; i < n; ++i) av_store(av, i,   newSVnv(((t*)data)[i]))

#define GDP_UNPACKC(t) \
  if (sp) { \
    EXTEND(sp, n); \
    for (i = 0; i < n; ++i) \
      PUSHs(sv_2mortal(gdp_newSVcmp(((t*)data)[2 * i], \
              ((t*)data)[2 * i + 1]))); \
  } else for (i = 0; i < n; ++i) av_store(av, i, \
      gdp_newSVcmp(((t*)data)[2 * i], ((t*)data)[2 * i + 1]))

/* unpack data. If sp is NULL, return an AV, otherwise push it onto the perl
 * stack; returns the updated stack pointer */
static void * gdp_unpack(SV **sp, const void *data, size_t n, gd_type_t type)
{
  dtrace("%p, %p, %" PRIuSIZE ", %03x", sp, data, n, type);
  size_t i;
  AV *av = NULL;

  if (!sp) {
    av = newAV();
    av_extend(av, n - 1);
  }

  if (n == 0) {
    dreturn("%p", sp);
    return sp ? (void *)sp : (void *)av;
  }

  switch (type) {
    case GD_UINT8:
      GDP_UNPACKU(uint8_t);
      break;
    case GD_INT8:
      GDP_UNPACKI(int8_t);
      break;
    case GD_UINT16:
      GDP_UNPACKU(uint16_t);
      break;
    case GD_INT16:
      GDP_UNPACKI(int16_t);
      break;
    case GD_UINT32:
      GDP_UNPACKU(uint32_t);
      break;
    case GD_INT32:
      GDP_UNPACKI(int32_t);
      break;
    case GD_UINT64:
      GDP_UNPACKU(uint64_t);
      break;
    case GD_INT64:
      GDP_UNPACKI(int64_t);
      break;
    case GD_FLOAT32:
      GDP_UNPACKN(float);
      break;
    case GD_FLOAT64:
      GDP_UNPACKN(double);
      break;
    case GD_COMPLEX64:
      GDP_UNPACKC(float);
      break;
    case GD_COMPLEX128:
      GDP_UNPACKC(double);
      break;
    case GD_UNKNOWN:
    case GD_NULL:
    case GD_STRING:
      break;
  }

  dreturn("%p", sp ? (void *)sp : (void *)av);
  return sp ? (void *)sp : (void *)av;
}

/* Module starts here --------------------------------------------------- */
#line 1188 "GetData.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 1330 "GetData.c"

XS_EUPXS(XS_GetData_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_DESTROY)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gdp_dirfile");
    {
	struct gdp_dirfile_t *	gdp_dirfile;
#line 1189 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 1343 "GetData.c"

  if (sv_isa(ST(0), "GetData::Dirfile"))
    gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
  else
    croak("%s::DESTROY() - Invalid dirfile object", gdp_package)
;
#line 1193 "GetData.xs"
    dtrace("%p", gdp_dirfile);
    if (gdp_dirfile->D != NULL)
      gd_discard(gdp_dirfile->D);
    safefree(gdp_dirfile);
#line 1355 "GetData.c"
#line 1198 "GetData.xs"
    dreturnvoid();
#line 1358 "GetData.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GetData_error); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_error)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 1204 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 1375 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::error() - Invalid dirfile object", gdp_package);
  }
;
#line 1208 "GetData.xs"
    dtrace("%p", dirfile);

    RETVAL = gd_error(dirfile);
#line 1394 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1214 "GetData.xs"
    dreturn("%i", RETVAL);
#line 1398 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfilename, flags, sehandler=undef, extra=undef");
    {
	const char *	dirfilename = (const char *)SvPV_nolen(ST(0))
;
	unsigned long	flags = (unsigned long)SvUV(ST(1))
;
	SV *	sehandler;
	SV *	extra;
	struct gdp_dirfile_t *	RETVAL;

	if (items < 3)
	    sehandler = undef;
	else {
	    sehandler = ST(2)
;
	}

	if (items < 4)
	    extra = undef;
	else {
	    extra = ST(3)
;
	}
#line 1224 "GetData.xs"
    dtrace("\"%s\", %lu, %p, %p", dirfilename, flags, sehandler, extra);
    Newx(RETVAL, 1, struct gdp_dirfile_t);
    if (sehandler == undef) {
      RETVAL->cbdata.func = NULL;
      RETVAL->cbdata.data = NULL;

      RETVAL->D = gd_cbopen(dirfilename, flags, NULL, NULL);
    } else {
      RETVAL->cbdata.func = sehandler;
      RETVAL->cbdata.data = extra;

      RETVAL->D = gd_cbopen(dirfilename, flags, gdp_parser_callback,
          &RETVAL->cbdata);
    }
#line 1447 "GetData.c"
	ST(0) = sv_newmortal();
  sv_setref_uv(ST(0), "GetData::Dirfile", PTR2UV(RETVAL));
#line 1241 "GetData.xs"
    dreturn("%p", RETVAL);
#line 1452 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_invalid_dirfile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_invalid_dirfile)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	struct gdp_dirfile_t *	RETVAL;
#line 1246 "GetData.xs"
    dtracevoid();
    Newx(RETVAL, 1, struct gdp_dirfile_t);
    RETVAL->cbdata.func = NULL;
    RETVAL->cbdata.data = NULL;

    RETVAL->D = gd_invalid_dirfile();
#line 1473 "GetData.c"
	ST(0) = sv_newmortal();
  sv_setref_uv(ST(0), "GetData::Dirfile", PTR2UV(RETVAL));
#line 1255 "GetData.xs"
    dreturn("%p", RETVAL);
#line 1478 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_get_carray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_carray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, field_code, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(2))
;
#line 1263 "GetData.xs"
    void *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 1502 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_carray() - Invalid dirfile object", gdp_package);
  }
;
#line 1268 "GetData.xs"
    dtrace("%p, \"%s\", %03x; %i", dirfile, field_code, return_type,
        (int)GIMME_V);

    if (return_type == GD_NULL) {
      gd_get_carray(dirfile, field_code, GD_NULL, NULL);

      GDP_UNDEF_ON_ERROR();

      if (GIMME_V != G_ARRAY) {
        dreturnvoid();
        XSRETURN_UNDEF;
      }
    } else {
      size_t len = gd_array_len(dirfile, field_code);
      Newx(data_out, GD_SIZE(return_type) * len, char);
      gd_get_carray(dirfile, field_code, return_type, data_out);

      GDP_UNDEF_ON_ERROR(safefree(data_out));

      if (GIMME_V == G_ARRAY)
        sp = (SV **)gdp_unpack(sp, data_out, len, return_type);
      else
        XPUSHs(sv_2mortal(newSVpvn(data_out, len * GD_SIZE(return_type))));

      safefree(data_out);
    }

    dreturnvoid();
#line 1544 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_get_carray_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_carray_slice)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, field_code, start, len, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(4))
;
	unsigned int	start = (unsigned int)SvUV(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 1305 "GetData.xs"
    void *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 1573 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_carray_slice() - Invalid dirfile object", gdp_package);
  }
;
#line 1310 "GetData.xs"
    dtrace("%p, \"%s\", %u, %" PRIuSIZE ", %03x; %i", dirfile, field_code,
      start, len, return_type, (int)GIMME_V);

    if (return_type == GD_NULL) {
      gd_get_carray_slice(dirfile, field_code, start, len, GD_NULL, NULL);

      GDP_UNDEF_ON_ERROR();

      if (GIMME_V != G_ARRAY) {
        dreturnvoid();
        XSRETURN_UNDEF;
      }
    } else {
      Newx(data_out, GD_SIZE(return_type) * len, char);
      gd_get_carray_slice(dirfile, field_code, start, len, return_type,
        data_out);

      GDP_UNDEF_ON_ERROR(safefree(data_out));

      if (GIMME_V == G_ARRAY)
        sp = (SV **)gdp_unpack(sp, data_out, len, return_type);
      else
        XPUSHs(sv_2mortal(newSVpvn(data_out, len * GD_SIZE(return_type))));

      safefree(data_out);
    }
    dreturnvoid();
#line 1614 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_get_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, field_code, return_type");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(2))
;
#line 1344 "GetData.xs"
    char data_out[16];
    GDP_DIRFILE_ALIAS;
#line 1637 "GetData.c"
	SV *	RETVAL;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_constant() - Invalid dirfile object", gdp_package);
  }
;
#line 1349 "GetData.xs"
    gd_type_t type;
    dtrace("%p, \"%s\", %03x", dirfile, field_code, return_type);

    if (return_type == GD_NULL)
      type = GD_NULL;
    else if (return_type & GD_COMPLEX)
      type = GD_COMPLEX128;
    else if (return_type & GD_IEEE754)
      type = GD_FLOAT64;
    else if (return_type & GD_SIGNED)
      type = GD_INT64;
    else
      type = GD_UINT64;

    gd_get_constant(dirfile, field_code, type, data_out);

    GDP_UNDEF_ON_ERROR();

    if (type == GD_NULL) {
      dreturnvoid();
      XSRETURN_UNDEF;
    } else if (type == GD_COMPLEX128)
      RETVAL = gdp_newSVcmp(((double*)data_out)[0], ((double*)data_out)[1]);
    else if (type == GD_FLOAT64)
      RETVAL = newSVnv(*(double*)data_out);
    else if (type == GD_INT64)
      RETVAL = newSViv(*(int64_t*)data_out);
    else
      RETVAL = newSVuv(*(uint64_t*)data_out);
#line 1681 "GetData.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
#line 1381 "GetData.xs"
    dreturn("%p", RETVAL);
#line 1686 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_constants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_constants)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(1))
;
#line 1388 "GetData.xs"
    const void *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 1708 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::constants() - Invalid dirfile object", gdp_package);
  }
;
#line 1393 "GetData.xs"
    dtrace("%p, %03x; %i", dirfile, return_type, (int)GIMME_V);
    int len = gd_nfields_by_type(dirfile, GD_CONST_ENTRY);
    data_out = gd_constants(dirfile, return_type);

    GDP_UNDEF_ON_ERROR();

    if (GIMME_V == G_ARRAY)
      sp = (SV **)gdp_unpack(sp, data_out, len, return_type);
    else
      XPUSHs(sv_2mortal(newSVpvn(data_out, len * GD_SIZE(return_type))));

    dreturnvoid();
#line 1734 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_carrays); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_carrays)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(1))
;
#line 1411 "GetData.xs"
    const gd_carray_t *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 1757 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::carrays() - Invalid dirfile object", gdp_package);
  }
;
#line 1416 "GetData.xs"
    dtrace("%p, %03x; %i", dirfile, return_type, (int)GIMME_V);
    I32 i, len = (I32)gd_nfields_by_type(dirfile, GD_CARRAY_ENTRY);
    data_out = gd_carrays(dirfile, return_type);

    GDP_UNDEF_ON_ERROR();

    /* in array context, return an array of arrays of unpacked data.
     * Otherwise, return a reference to an array of packed data. */
    if (GIMME_V == G_ARRAY) {
      EXTEND(sp, len);
      for (i = 0; i < len; ++i)
        PUSHs(sv_2mortal(newRV_noinc((SV *)gdp_unpack(NULL, data_out[i].d,
                  data_out[i].n, return_type))));
    } else {
      AV *av = newAV();
      for (i = 0; i < len; ++i)
        av_store(av, i, newSVpvn(data_out[i].d,
              data_out[i].n * GD_SIZE(return_type)));
      XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }

    dreturnvoid();
#line 1793 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_entry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_entry)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1444 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 1815 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::entry() - Invalid dirfile object", gdp_package);
  }
;
#line 1448 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, field_code, (int)GIMME_V);

    if (GIMME_V == G_ARRAY) {
      gd_entry_t E;
      gd_entry(dirfile, field_code, &E);

      GDP_UNDEF_ON_ERROR();

      /* push the hash onto the stack */
      EXTEND(sp, 6);
      GDP_PUSHpvn("field");
      GDP_PUSHpvz(E.field);
      GDP_PUSHpvn("field_type");
      GDP_PUSHuv(E.field_type);
      GDP_PUSHpvn("fragment_index");
      GDP_PUSHuv(E.fragment_index);
      switch (E.field_type) {
        case GD_BIT_ENTRY:
        case GD_SBIT_ENTRY:
          EXTEND(sp, 6);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHpvz(E.in_fields[0]);
          GDP_PUSHpvn("bitnum");
          GDP_PUSHuv(E.EN(bit,bitnum));
          GDP_PUSHpvn("numbits");
          GDP_PUSHuv(E.EN(bit,numbits));
          sp = gdp_store_scalars(sp, &E, 0x3);
          break;
        case GD_SARRAY_ENTRY:
          EXTEND(sp, 2);
          GDP_PUSHpvn("array_len");
          GDP_PUSHuv(E.EN(scalar,array_len));
          break;
        case GD_CARRAY_ENTRY:
          EXTEND(sp, 2);
          GDP_PUSHpvn("array_len");
          GDP_PUSHuv(E.EN(scalar,array_len));
          /* fallthrough */
        case GD_CONST_ENTRY:
          EXTEND(sp, 2);
          GDP_PUSHpvn("const_type");
          GDP_PUSHuv(E.EN(scalar,const_type));
          break;
        case GD_LINCOM_ENTRY:
          EXTEND(sp, 8);
          GDP_PUSHpvn("n_fields");
          GDP_PUSHiv(E.EN(lincom,n_fields));
          GDP_PUSHpvn("in_fields");
          GDP_PUSHrvavpv(E.in_fields, E.EN(lincom,n_fields));
          GDP_PUSHpvn("m");
          GDP_PUSHrvavcmp(E.EN(lincom,cm), E.EN(lincom,n_fields));
          GDP_PUSHpvn("b");
          GDP_PUSHrvavcmp(E.EN(lincom,cb), E.EN(lincom,n_fields));
          sp = gdp_store_scalars(sp, &E,
              ((1 << E.EN(lincom,n_fields)) - 1) * 9);
          break;
        case GD_LINTERP_ENTRY:
          EXTEND(sp, 4);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHpvz(E.in_fields[0]);
          GDP_PUSHpvn("table");
          GDP_PUSHpvz(E.EN(linterp,table));
          break;
        case GD_MULTIPLY_ENTRY:
        case GD_DIVIDE_ENTRY:
        case GD_INDIR_ENTRY:
        case GD_SINDIR_ENTRY:
          EXTEND(sp, 2);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHrvavpv(E.in_fields, 2);
          break;
        case GD_PHASE_ENTRY:
          EXTEND(sp, 4);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHpvz(E.in_fields[0]);
          GDP_PUSHpvn("shift");
          GDP_PUSHiv(E.EN(phase,shift));
          sp = gdp_store_scalars(sp, &E, 1);
          break;
        case GD_POLYNOM_ENTRY:
          EXTEND(sp, 6);
          GDP_PUSHpvn("poly_ord");
          GDP_PUSHiv(E.EN(polynom,poly_ord));
          GDP_PUSHpvn("in_fields");
          GDP_PUSHpvz(E.in_fields[0]);
          GDP_PUSHpvn("a");
          GDP_PUSHrvavcmp(E.EN(polynom,ca), E.EN(polynom,poly_ord) + 1);
          sp = gdp_store_scalars(sp, &E,
              (1 << (E.EN(polynom,poly_ord) + 1)) - 1);
          break;
        case GD_RECIP_ENTRY:
          EXTEND(sp, 4);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHpvz(E.in_fields[0]);
          GDP_PUSHpvn("dividend");
          GDP_PUSHcmp(creal(E.EN(recip,cdividend)),
              cimag(E.EN(recip,cdividend)));
          sp = gdp_store_scalars(sp, &E, 1);
          break;
        case GD_RAW_ENTRY:
          EXTEND(sp, 4);
          GDP_PUSHpvn("spf");
          GDP_PUSHuv(E.EN(raw,spf));
          GDP_PUSHpvn("data_type");
          GDP_PUSHuv(E.EN(raw,data_type));
          sp = gdp_store_scalars(sp, &E, 1);
          break;
        case GD_WINDOW_ENTRY:
          EXTEND(sp, 6);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHrvavpv(E.in_fields, 2);
          GDP_PUSHpvn("windop");
          GDP_PUSHiv(E.EN(window,windop));
          GDP_PUSHpvn("threshold");
          switch(E.EN(window,windop)) {
            case GD_WINDOP_EQ:
            case GD_WINDOP_NE:
              GDP_PUSHiv(E.EN(window,threshold).i);
              break;
            case GD_WINDOP_SET:
            case GD_WINDOP_CLR:
              GDP_PUSHuv(E.EN(window,threshold).u);
              break;
            default:
              GDP_PUSHnv(E.EN(window,threshold).r);
              break;
          }
          sp = gdp_store_scalars(sp, &E, 1);
          break;
        case GD_MPLEX_ENTRY:
          EXTEND(sp, 6);
          GDP_PUSHpvn("in_fields");
          GDP_PUSHrvavpv(E.in_fields, 2);
          GDP_PUSHpvn("count_val");
          GDP_PUSHuv(E.EN(mplex,count_val));
          GDP_PUSHpvn("period");
          GDP_PUSHuv(E.EN(mplex,period));
          sp = gdp_store_scalars(sp, &E, 0x3);
          break;
        case GD_INDEX_ENTRY:
        case GD_STRING_ENTRY:
        case GD_ALIAS_ENTRY: /* avoid compiler warnings */
        case GD_NO_ENTRY:
          break;
      }

      gd_free_entry_strings(&E);
    } else {
      gd_entype_t t = gd_entry_type(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHiv(t);
    }
    dreturnvoid();
#line 1985 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_error_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_error_string)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 1609 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2003 "GetData.c"
	SV *	RETVAL;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::error_string() - Invalid dirfile object", gdp_package);
  }
;
#line 1613 "GetData.xs"
    dtrace("%p", dirfile);
    char *s = gd_error_string(dirfile, NULL, 0);

    RETVAL = newSVpv(s, 0);
#line 2022 "GetData.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
#line 1620 "GetData.xs"
    safefree(s);
    dreturn("%p", RETVAL);
#line 2028 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_mcarrays); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mcarrays)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, parent, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(2))
;
#line 1629 "GetData.xs"
    const gd_carray_t *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 2052 "GetData.c"
	AV *	RETVAL;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mcarrays() - Invalid dirfile object", gdp_package);
  }
;
#line 1634 "GetData.xs"
    dtrace("%p, %03x; %i", dirfile, return_type, (int)GIMME_V);
    I32 i, len = (I32)gd_nmfields_by_type(dirfile, parent, GD_CARRAY_ENTRY);
    data_out = gd_mcarrays(dirfile, parent, return_type);

    GDP_UNDEF_ON_ERROR();

    /* in array context, return an array of arrays of unpacked data.
     * Otherwise, return a reference to an array of packed data. */
    if (GIMME_V == G_ARRAY) {
      EXTEND(sp, len);
      for (i = 0; i < len; ++i)
        PUSHs(sv_2mortal(newRV_noinc((SV *)gdp_unpack(NULL, data_out[i].d,
                  data_out[i].n, return_type))));
    } else {
      AV *av = newAV();
      for (i = 0; i < len; ++i)
        av_store(av, i, newSVpvn(data_out[i].d,
              data_out[i].n * GD_SIZE(return_type)));
      XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }

    dreturnvoid();
#line 2089 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_mconstants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mconstants)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, parent, return_type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	return_type = (gd_type_t)SvIV(ST(2))
;
#line 1663 "GetData.xs"
    const void *data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 2114 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mconstants() - Invalid dirfile object", gdp_package);
  }
;
#line 1668 "GetData.xs"
    dtrace("%p, %03x; %i", dirfile, return_type, (int)GIMME_V);
    int len = gd_nmfields_by_type(dirfile, parent, GD_CONST_ENTRY);
    data_out = gd_mconstants(dirfile, parent, return_type);

    GDP_UNDEF_ON_ERROR();

    if (GIMME_V == G_ARRAY)
      sp = (SV **)gdp_unpack(sp, data_out, len, return_type);
    else
      XPUSHs(sv_2mortal(newSVpvn(data_out, len * GD_SIZE(return_type))));

    dreturnvoid();
#line 2140 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_parser_callback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_parser_callback)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "gdp_dirfile, sehandler, extra=undef");
    {
	struct gdp_dirfile_t *	gdp_dirfile;
	SV *	sehandler = ST(1)
;
	SV *	extra;
#line 1687 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2161 "GetData.c"

  if (sv_isa(ST(0), "GetData::Dirfile"))
    gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
  else
    croak("%s::parser_callback() - Invalid dirfile object", gdp_package)
;

	if (items < 3)
	    extra = undef;
	else {
	    extra = ST(2)
;
	}
#line 1691 "GetData.xs"
    dtrace("%p, %p, %p", gdp_dirfile, sehandler, extra);
    if (gdp_dirfile->D) {
      if (sehandler == undef) {
        gdp_dirfile->cbdata.func = NULL;
        gdp_dirfile->cbdata.data = NULL;

        gd_parser_callback(gdp_dirfile->D, NULL, NULL);
      } else {
        gdp_dirfile->cbdata.func = sehandler;
        gdp_dirfile->cbdata.data = extra;

        gd_parser_callback(gdp_dirfile->D, gdp_parser_callback,
            &gdp_dirfile->cbdata);
      }
    }
#line 2191 "GetData.c"
#line 1707 "GetData.xs"
    dreturnvoid();
#line 2194 "GetData.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GetData_get_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_string)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1714 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2213 "GetData.c"
	char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_string() - Invalid dirfile object", gdp_package);
  }
;
#line 1718 "GetData.xs"
    dtrace("%p, \"%s\"", dirfile, field_code);

    /* get string length */
    size_t len = gd_get_string(dirfile, field_code, 0, NULL);
    Newx(RETVAL, len, char);

    /* get string */
    gd_get_string(dirfile, field_code, len, RETVAL);
#line 2237 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 1729 "GetData.xs"
    dreturn("\"%s\"", RETVAL);
    safefree(RETVAL);
#line 2242 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_close)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gdp_dirfile");
    {
	struct gdp_dirfile_t *	gdp_dirfile;
#line 1736 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2259 "GetData.c"
	int	RETVAL;
	dXSTARG;

  if (sv_isa(ST(0), "GetData::Dirfile"))
    gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
  else
    croak("%s::close() - Invalid dirfile object", gdp_package)
;
#line 1740 "GetData.xs"
    dtrace("%p", gdp_dirfile);

    if (gdp_dirfile->D != NULL) {
      RETVAL = gd_close(gdp_dirfile->D);

      if (!RETVAL)
        gdp_dirfile->D = NULL;
    } else
      RETVAL = 0;
#line 2278 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1752 "GetData.xs"
    dreturn("%i", RETVAL);
#line 2282 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_discard); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_discard)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "gdp_dirfile");
    {
	struct gdp_dirfile_t *	gdp_dirfile;
#line 1758 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2299 "GetData.c"
	int	RETVAL;
	dXSTARG;

  if (sv_isa(ST(0), "GetData::Dirfile"))
    gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
  else
    croak("%s::discard() - Invalid dirfile object", gdp_package)
;
#line 1762 "GetData.xs"
    dtrace("%p", gdp_dirfile);

    if (gdp_dirfile->D != NULL) {
      RETVAL = gd_discard(gdp_dirfile->D);

      if (!RETVAL)
        gdp_dirfile->D = NULL;
    } else
      RETVAL = 0;
#line 2318 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1774 "GetData.xs"
    dreturn("%i", RETVAL);
#line 2322 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_getdata); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_getdata)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "dirfile, field_code, first_frame, first_samp, num_frames, num_samp, return_type=GD_UNKNOWN");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_off64_t	first_frame = (gd_off64_t)SvIV(ST(2))
;
	gd_off64_t	first_samp = (gd_off64_t)SvIV(ST(3))
;
	size_t	num_frames = (size_t)SvUV(ST(4))
;
	size_t	num_samp = (size_t)SvUV(ST(5))
;
	gd_type_t	return_type;
#line 1787 "GetData.xs"
    unsigned int spf = 1;
    gd_entype_t t;
    GDP_DIRFILE_ALIAS;
    size_t i, len;
    void * data_out;
#line 2356 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::getdata() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 7)
	    return_type = GD_UNKNOWN;
	else {
	    return_type = (gd_type_t)SvIV(ST(6))
;
	}
#line 1795 "GetData.xs"
    dtrace("%p, \"%s\", %" PRId64 ", %" PRId64 ", %" PRIuSIZE ", %" PRIuSIZE
      ", %03x; %i", dirfile, field_code, (int64_t)first_frame,
      (int64_t)first_samp, num_frames, num_samp, return_type, (int)GIMME_V);

    t = gd_entry_type(dirfile, field_code);

    GDP_UNDEF_ON_ERROR();

    if (num_frames) {
      spf = gd_spf(dirfile, field_code);

      num_samp += spf * num_frames;

      GDP_UNDEF_ON_ERROR();
    }

    if (t == GD_SINDIR_ENTRY) {
      const char **data_out;
      Newx(data_out, num_samp, const char*);

      len = gd_getdata64(dirfile, field_code, first_frame, first_samp, 0,
          num_samp, GD_STRING, data_out);

      GDP_UNDEF_ON_ERROR(safefree(data_out));

      /* In array context return the array; in scalar context return a reference
       * to an array */
      if (GIMME_V == G_ARRAY)
        for (i = 0; i < len; ++i)
          GDP_PUSHpvz(data_out[i]);
      else
        XPUSHs(sv_2mortal(gdp_newRVavpv(data_out, len)));

      safefree(data_out);
    } else if (return_type == GD_UNKNOWN)
      croak("%s::getdata() - No return type specified", gdp_package);
    else if (return_type == GD_NULL) {
      len = gd_getdata64(dirfile, field_code, first_frame, first_samp, 0,
          num_samp, GD_NULL, NULL);

      GDP_UNDEF_ON_ERROR();

      /* For GD_NULL, we return len in scalar context and an empty array
       * in array context */
      if (GIMME_V == G_ARRAY)
        ; /* nothing to return */
      else {
        EXTEND(sp, 1);
        GDP_PUSHuv(len);
      }
    } else {
      Newx(data_out, GD_SIZE(return_type) * num_samp, char);

      len = gd_getdata64(dirfile, field_code, first_frame, first_samp, 0,
          num_samp, return_type, data_out);

      GDP_UNDEF_ON_ERROR(safefree(data_out));

      /* In array context, unpack the array and push it onto the stack,
       * otherwise just return the packed data */
      if (GIMME_V == G_ARRAY)
        sp = (SV **)gdp_unpack(sp, data_out, len, return_type);
      else
        XPUSHs(sv_2mortal(newSVpvn(data_out, len * GD_SIZE(return_type))));

      safefree(data_out);
    }

    dreturnvoid();
#line 2446 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_field_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_field_list)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
#line 1869 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2466 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::field_list() - Invalid dirfile object", gdp_package);
  }
;
#line 1873 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_field_list(dirfile);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nfields(dirfile);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2503 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_field_list_by_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_field_list_by_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	gd_entype_t	type = (gd_entype_t)SvUV(ST(1))
;
#line 1902 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2525 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::field_list_by_type() - Invalid dirfile object", gdp_package);
  }
;
#line 1906 "GetData.xs"
    dtrace("%p, %i; %i", dirfile, type, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_field_list_by_type(dirfile, type);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nfields_by_type(dirfile, type);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2562 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_entry_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_entry_list)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, parent, type, flags");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	gdp_char *	parent;
	gdp_int	type;
	gdp_uint_t	flags;
#line 1937 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2585 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::entry_list() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(1) == undef)
    parent = NULL;
  else
    parent = SvPV_nolen(ST(1))
;

  if (ST(2) == undef)
    type = (gdp_int)0;
  else
    type = (gdp_int)SvIV(ST(2))
;

  if (ST(3) == undef)
    flags = (gdp_uint_t)0;
  else
    flags = (gdp_uint_t)SvUV(ST(3))
;
#line 1941 "GetData.xs"
    dtrace("%p, \"%s\", %i, %u; %i", dirfile, parent, type, flags,
        (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **el = gd_entry_list(dirfile, parent, type, flags);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; el[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(el[i]);
      }
    } else {
      unsigned int ne = gd_nentries(dirfile, parent, type, flags);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(ne);
    }

    dreturnvoid();
#line 2641 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_match_entries); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_match_entries)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, regex, fragment=-1, type=0, flags=0");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	gdp_char *	regex;
	gdp_ffff_t	fragment;
	gdp_int	type;
	gdp_uint_t	flags;
#line 1974 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    const char **el;
    unsigned int ne;
#line 2667 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::match_entries() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(1) == undef)
    regex = NULL;
  else
    regex = SvPV_nolen(ST(1))
;

	if (items < 3)
	    fragment = -1;
	else {
  if (ST(2) == undef)
    fragment = (gdp_ffff_t)-1;
  else
    fragment = (gdp_ffff_t)SvIV(ST(2))
;
	}

	if (items < 4)
	    type = 0;
	else {
  if (ST(3) == undef)
    type = (gdp_int)0;
  else
    type = (gdp_int)SvIV(ST(3))
;
	}

	if (items < 5)
	    flags = 0;
	else {
  if (ST(4) == undef)
    flags = (gdp_uint_t)0;
  else
    flags = (gdp_uint_t)SvUV(ST(4))
;
	}
#line 1980 "GetData.xs"
    dtrace("%p, \"%s\", %i, %i, %u; %i", dirfile, regex, fragment, type, flags,
        (int)GIMME_V);

    ne = gd_match_entries(dirfile, regex, fragment, type, flags, &el);

    GDP_UNDEF_ON_ERROR();

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;

      for (i = 0; el[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(el[i]);
      }
    } else {
      EXTEND(sp, 1);
      GDP_PUSHuv(ne);
    }

    dreturnvoid();
#line 2738 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_vector_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_vector_list)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
#line 2006 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2758 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::vector_list() - Invalid dirfile object", gdp_package);
  }
;
#line 2010 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_vector_list(dirfile);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nvectors(dirfile);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2795 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_strings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_strings)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
#line 2038 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2815 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::strings() - Invalid dirfile object", gdp_package);
  }
;
#line 2042 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_strings(dirfile);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nfields_by_type(dirfile, GD_STRING_ENTRY);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2852 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_mfield_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mfield_list)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 2071 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2874 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mfield_list() - Invalid dirfile object", gdp_package);
  }
;
#line 2075 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, field_code, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_mfield_list(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nmfields(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2911 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_mfield_list_by_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mfield_list_by_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, parent, type");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	gd_entype_t	type = (gd_entype_t)SvUV(ST(2))
;
#line 2105 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2935 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mfield_list_by_type() - Invalid dirfile object", gdp_package);
  }
;
#line 2109 "GetData.xs"
    dtrace("%p, \"%s\", %i; %i", dirfile, parent, type, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_mfield_list_by_type(dirfile, parent, type);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nmfields_by_type(dirfile, parent, type);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 2972 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_mvector_list); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mvector_list)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, parent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
#line 2138 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 2994 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mvector_list() - Invalid dirfile object", gdp_package);
  }
;
#line 2142 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_mvector_list(dirfile, parent);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nmvectors(dirfile, parent);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 3031 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_mstrings); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mstrings)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 2171 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 3053 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mstrings() - Invalid dirfile object", gdp_package);
  }
;
#line 2175 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, field_code, (int)GIMME_V);

    /* in array context, return the field list, otherwise return nfields */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_mstrings(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_nmfields_by_type(dirfile, field_code,
          GD_STRING_ENTRY);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 3091 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_put_carray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_carray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3)
       croak_xs_usage(cv,  "dirfile, field_code, d, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	SV *	d = ST(2)
;
#line 2206 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    struct gdp_din din;
#line 3114 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_carray() - Invalid dirfile object", gdp_package);
  }
;
#line 2211 "GetData.xs"
    dtrace("%p, \"%s\", %p, ...[%li]", dirfile, field_code, d, (long)items - 3);

    din = gdp_convert_data(d, items, ax, 2, gdp_package, "put_carray");

    RETVAL = gd_put_carray(dirfile, field_code, din.type, din.data_in);

    GDP_UNDEF_ON_ERROR(if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in));
#line 3138 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2222 "GetData.xs"
    if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in);
    dreturn("%i", RETVAL);
#line 3144 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_put_carray_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_carray_slice)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4)
       croak_xs_usage(cv,  "dirfile, field_code, start, d, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_off64_t	start = (gd_off64_t)SvIV(ST(2))
;
	SV *	d = ST(3)
;
#line 2233 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    struct gdp_din din;
#line 3168 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_carray_slice() - Invalid dirfile object", gdp_package);
  }
;
#line 2238 "GetData.xs"
    dtrace("%p, \"%s\", %" PRId64 ", %p, ...[%li]", dirfile, field_code,
        (int64_t)start, d, (long)items - 4);

    din = gdp_convert_data(d, items, ax, 3, gdp_package, "put_carray_slice");

    RETVAL = gd_put_carray_slice(dirfile, field_code, start, din.nsamp,
        din.type, din.data_in);

    GDP_UNDEF_ON_ERROR(if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in));
#line 3194 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2251 "GetData.xs"
    if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in);
    dreturn("%i", RETVAL);
#line 3200 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_carray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_carray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5)
       croak_xs_usage(cv,  "dirfile, field_code, const_type, fragment_index, d, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	fragment_index = (int)SvIV(ST(3))
;
	gd_type_t	const_type = (gd_type_t)SvIV(ST(2))
;
	SV *	d = ST(4)
;
#line 2263 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    struct gdp_din din;
#line 3226 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_carray() - Invalid dirfile object", gdp_package);
  }
;
#line 2268 "GetData.xs"
    dtrace("%p, \"%s\", %03x, %i, %p, ...[%li]", dirfile, field_code,
        const_type, fragment_index, d, (long)items - 5);

    din = gdp_convert_data(d, items, ax, 4, gdp_package, "add_carray");

    RETVAL = gd_add_carray(dirfile, field_code, const_type, din.nsamp,
        din.type, din.data_in, fragment_index);

    GDP_UNDEF_ON_ERROR(if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in));
#line 3252 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2281 "GetData.xs"
    if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in);
    dreturn("%i", RETVAL);
#line 3258 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_carray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_carray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, const_type, d, ...");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	gd_type_t	const_type = (gd_type_t)SvIV(ST(3))
;
	SV *	d = ST(4)
;
#line 2293 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    struct gdp_din din;
#line 3284 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_carray() - Invalid dirfile object", gdp_package);
  }
;
#line 2298 "GetData.xs"
    dtrace("%p, \"%s\", \"%s\", %03x, %p, ...[%li]", dirfile, parent,
        field_code, const_type, d, (long)items - 5);

    din = gdp_convert_data(d, items, ax, 4, gdp_package, "madd_carray");

    RETVAL = gd_madd_carray(dirfile, parent, field_code, const_type, din.nsamp,
        din.type, din.data_in);

    GDP_UNDEF_ON_ERROR(if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in));
#line 3310 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2311 "GetData.xs"
    if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in);
    dreturn("%i", RETVAL);
#line 3316 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_putdata); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_putdata)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5)
       croak_xs_usage(cv,  "dirfile, field_code, first_frame, first_sample, d, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_off64_t	first_frame = (gd_off64_t)SvIV(ST(2))
;
	gd_off64_t	first_sample = (gd_off64_t)SvIV(ST(3))
;
	SV *	d = ST(4)
;
#line 2323 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    struct gdp_din din;
#line 3342 "GetData.c"
	size_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::putdata() - Invalid dirfile object", gdp_package);
  }
;
#line 2328 "GetData.xs"
    dtrace("%p, \"%s\", %" PRId64 ", %" PRId64 ", %p, ...[%li]", dirfile,
      field_code, (int64_t)first_frame, (int64_t)first_sample, d,
      (long)items - 5);

    din = gdp_convert_data(d, items, ax, 4, gdp_package, "putdata");

    RETVAL = gd_putdata(dirfile, field_code, first_frame, first_sample, 0,
        din.nsamp, din.type, din.data_in);

    GDP_UNDEF_ON_ERROR(if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in));
#line 3369 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 2342 "GetData.xs"
    if (din.arg_type != GDP_DATA_IN_PACK)
      safefree(din.data_in);
    dreturn("%" PRIuSIZE, RETVAL);
#line 3375 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_const); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_const)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, const_type, value=undef, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	const_type = (gd_type_t)SvIV(ST(2))
;
	SV *	value;
	int	fragment_index;
#line 2354 "GetData.xs"
    gd_type_t data_type;
    char data_in[16];
    GDP_DIRFILE_ALIAS;
#line 3400 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_const() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    value = undef;
	else {
	    value = ST(3)
;
	}

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 2360 "GetData.xs"
    dtrace("%p, \"%s\", %03x, %p, %i", dirfile, field_code, const_type, value,
        fragment_index);

    data_type = gdp_to_voidp(data_in, value, const_type, gdp_package,
      "add_const");

    RETVAL = gd_add_const(dirfile, field_code, const_type, data_type, data_in,
        fragment_index);

    GDP_UNDEF_ON_ERROR();
#line 3440 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2373 "GetData.xs"
    dreturn("%i", RETVAL);
#line 3444 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_const); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_const)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, const_type, value=undef");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	gd_type_t	const_type = (gd_type_t)SvIV(ST(3))
;
	SV *	value;
#line 2383 "GetData.xs"
    gd_type_t data_type;
    char data_in[16];
    GDP_DIRFILE_ALIAS;
#line 3470 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_const() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    value = undef;
	else {
	    value = ST(4)
;
	}
#line 2389 "GetData.xs"
    dtrace("%p, \"%s\", \"%s\", %03x, %p", dirfile, parent, field_code,
        const_type, value);

    data_type = gdp_to_voidp(data_in, value, const_type, gdp_package,
      "madd_const");

    RETVAL = gd_madd_const(dirfile, parent, field_code, const_type, data_type,
        data_in);

    GDP_UNDEF_ON_ERROR();
#line 3503 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2402 "GetData.xs"
    dreturn("%i", RETVAL);
#line 3507 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_put_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, field_code, value");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	SV *	value = ST(2)
;
#line 2410 "GetData.xs"
    gd_type_t data_type;
    char data_in[16];
    GDP_DIRFILE_ALIAS;
#line 3530 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_constant() - Invalid dirfile object", gdp_package);
  }
;
#line 2416 "GetData.xs"
    dtrace("%p, \"%s\", %p", dirfile, field_code, value);

    data_type = gdp_to_voidp(data_in, value, GD_FLOAT64, gdp_package,
      "put_constant");

    RETVAL = gd_put_constant(dirfile, field_code, data_type, data_in);

    GDP_UNDEF_ON_ERROR();
#line 3554 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2427 "GetData.xs"
    dreturn("%i", RETVAL);
#line 3558 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_fragments); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_fragments)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
#line 2433 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    int nf;
#line 3578 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::fragments() - Invalid dirfile object", gdp_package);
  }
;
#line 2438 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);

    nf = gd_nfragments(dirfile);

    if (GIMME_V == G_ARRAY) {
      int i;
      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, nf);
      for (i = 0; i < nf; ++i)
        GDP_PUSHpvz(gd_fragmentname(dirfile, i));
    } else {
      EXTEND(sp, 1);
      GDP_PUSHiv(nf);
    }

    dreturnvoid();
#line 3609 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_aliases); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_aliases)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 2461 "GetData.xs"
    GDP_DIRFILE_ALIAS;
#line 3631 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::aliases() - Invalid dirfile object", gdp_package);
  }
;
#line 2465 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, field_code, (int)GIMME_V);

    /* in array context, return the field list, otherwise return naliases */
    if (GIMME_V == G_ARRAY) {
      int i;
      const char **fl = gd_aliases(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      for (i = 0; fl[i]; ++i) {
        EXTEND(sp, 1);
        GDP_PUSHpvz(fl[i]);
      }
    } else {
      unsigned int nf = gd_naliases(dirfile, field_code);

      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHuv(nf);
    }

    dreturnvoid();
#line 3668 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_fragment_affixes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_fragment_affixes)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment_index");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	int	fragment_index = (int)SvIV(ST(1))
;
#line 2494 "GetData.xs"
    char *prefix;
    char *suffix;
    GDP_DIRFILE_ALIAS;
#line 3692 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::fragment_affixes() - Invalid dirfile object", gdp_package);
  }
;
#line 2500 "GetData.xs"
    dtrace("%p, %i", dirfile, fragment_index);

    gd_fragment_affixes(dirfile, fragment_index, &prefix, &suffix);

    GDP_UNDEF_ON_ERROR();

    EXTEND(sp, 2);
    GDP_PUSHpvz(prefix);
    GDP_PUSHpvz(suffix);

    dreturnvoid();
#line 3717 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_strtok); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_strtok)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, string");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	string = (const char *)SvPV_nolen(ST(1))
;
#line 2517 "GetData.xs"
    char *token;
    GDP_DIRFILE_ALIAS;
#line 3740 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::strtok() - Invalid dirfile object", gdp_package);
  }
;
#line 2522 "GetData.xs"
    dtrace("%p, \"%s\"", dirfile, string);

    /* return an array of all the parsed tokens */
    for (token = gd_strtok(dirfile, string); token;
      token = gd_strtok(dirfile, NULL))
    {
      GDP_UNDEF_ON_ERROR();

      EXTEND(sp, 1);
      GDP_PUSHpvz(token);
      safefree(token);
    }

    dreturnvoid();
#line 3768 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_include); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_include)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "dirfile, file, fragment_index, namespace=NULL, flags=0");
    {
	DIRFILE *	dirfile;
	const char *	file = (const char *)SvPV_nolen(ST(1))
;
	int	fragment_index = (int)SvIV(ST(2))
;
	unsigned long int	flags;
	gdp_char *	namespace;
#line 2545 "GetData.xs"
		GDP_DIRFILE_ALIAS;
#line 3792 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::include() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    flags = 0;
	else {
	    flags = (unsigned long int)SvUV(ST(4))
;
	}

	if (items < 4)
	    namespace = NULL;
	else {
  if (ST(3) == undef)
    namespace = NULL;
  else
    namespace = SvPV_nolen(ST(3))
;
	}
#line 2549 "GetData.xs"
		dtrace("%p, \"%s\", %i, \"%s\", %lu", dirfile, file, fragment_index,
        namespace, flags);

		RETVAL = gd_include_ns(dirfile, file, fragment_index, namespace, flags);
		GDP_UNDEF_ON_ERROR();
#line 3830 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2557 "GetData.xs"
		dreturn("%i", RETVAL);
#line 3834 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_carray_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_carray_len)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 2564 "GetData.xs"
		GDP_DIRFILE_ALIAS;
#line 3853 "GetData.c"
	size_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::carray_len() - Invalid dirfile object", gdp_package);
  }
;
#line 2568 "GetData.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
    warn("carray_len is deprecated.  Use array_len instead.");
		RETVAL = gd_array_len(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 3873 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 2575 "GetData.xs"
		dreturn("%" PRIuSIZE, RETVAL);
#line 3877 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_get_sarray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_sarray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 2582 "GetData.xs"
    size_t i, len;
    const char **data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 3900 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_sarray() - Invalid dirfile object", gdp_package);
  }
;
#line 2588 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, field_code, (int)GIMME_V);
    len = gd_array_len(dirfile, field_code);
    Newx(data_out, len, const char*);
    gd_get_sarray(dirfile, field_code, data_out);

    GDP_UNDEF_ON_ERROR(safefree(data_out));

    /* In array context return the array; in scalar context return a reference
     * to an array */
    if (GIMME_V == G_ARRAY)
      for (i = 0; i < len; ++i)
        GDP_PUSHpvz(data_out[i]);
    else
      XPUSHs(sv_2mortal(gdp_newRVavpv(data_out, len)));

    safefree(data_out);
    dreturnvoid();
#line 3931 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_get_sarray_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_get_sarray_slice)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, field_code, start, len");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	unsigned int	start = (unsigned int)SvUV(ST(2))
;
	size_t	len = (size_t)SvUV(ST(3))
;
#line 2613 "GetData.xs"
    size_t i;
    const char **data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 3959 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::get_sarray_slice() - Invalid dirfile object", gdp_package);
  }
;
#line 2619 "GetData.xs"
    dtrace("%p, \"%s\", %u, %" PRIuSIZE "; %i", dirfile, field_code, start, len,
        (int)GIMME_V);
    Newx(data_out, len, const char*);
    gd_get_sarray_slice(dirfile, field_code, start, len, data_out);

    GDP_UNDEF_ON_ERROR(safefree(data_out));

    if (GIMME_V == G_ARRAY)
      for (i = 0; i < len; ++i)
        GDP_PUSHpvz(data_out[i]);
    else
      XPUSHs(sv_2mortal(gdp_newRVavpv(data_out, len)));

    safefree(data_out);
    dreturnvoid();
#line 3988 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_sarrays); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_sarrays)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
#line 2639 "GetData.xs"
    int i;
    const char ***data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 4010 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::sarrays() - Invalid dirfile object", gdp_package);
  }
;
#line 2645 "GetData.xs"
    dtrace("%p; %i", dirfile, (int)GIMME_V);
    data_out = gd_sarrays(dirfile);

    GDP_UNDEF_ON_ERROR();

    /* in array context, return an array of arrays of strings.
     * Otherwise, return a reference to the same. */
    if (GIMME_V == G_ARRAY)
      for (i = 0; data_out[i]; ++i)
        XPUSHs(sv_2mortal(gdp_newRVavpv0(data_out[i])));
    else {
      AV *av = newAV();
      for (i = 0; data_out[i]; ++i)
        av_store(av, i, gdp_newRVavpv0(data_out[i]));
      XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }

    dreturnvoid();
#line 4042 "GetData.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_GetData_put_sarray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_sarray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3)
       croak_xs_usage(cv,  "dirfile, field_code, sv_in, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	SV *	sv_in = ST(2)
;
#line 2670 "GetData.xs"
    const char **data_in;
    GDP_DIRFILE_ALIAS;
#line 4065 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_sarray() - Invalid dirfile object", gdp_package);
  }
;
#line 2675 "GetData.xs"
    dtrace("%p, \"%s\", %p ...[%li]", dirfile, field_code, sv_in,
        (long)items - 3);

    data_in = gdp_convert_strarr(NULL, items, ax, 2, gdp_package, "put_sarray");

    RETVAL = gd_put_sarray(dirfile, field_code, data_in);

    GDP_UNDEF_ON_ERROR(safefree(data_in));
#line 4089 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2686 "GetData.xs"
    safefree(data_in);
    dreturn("%i", RETVAL);
#line 4094 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_put_sarray_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_sarray_slice)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4)
       croak_xs_usage(cv,  "dirfile, field_code, start, sv_in, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_off64_t	start = (gd_off64_t)SvIV(ST(2))
;
	SV *	sv_in = ST(3)
;
#line 2696 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    size_t len;
    const char **data_in;
#line 4119 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_sarray_slice() - Invalid dirfile object", gdp_package);
  }
;
#line 2702 "GetData.xs"
    dtrace("%p, \"%s\", %lli, %p ...[%li]", dirfile, field_code,
        (long long)start, sv_in, (long)items - 4);

    data_in = gdp_convert_strarr(&len, items, ax, 3, gdp_package,
        "put_sarray_slice");

    RETVAL = gd_put_sarray_slice(dirfile, field_code, start, len, data_in);

    GDP_UNDEF_ON_ERROR(safefree(data_in));
#line 4144 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2714 "GetData.xs"
    safefree(data_in);
    dreturn("%i", RETVAL);
#line 4149 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_sarray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_sarray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4)
       croak_xs_usage(cv,  "dirfile, field_code, fragment_index, sv_in, ...");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	fragment_index = (int)SvIV(ST(2))
;
	SV *	sv_in = ST(3)
;
#line 2724 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    size_t len;
    const char **data_in;
#line 4174 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_sarray() - Invalid dirfile object", gdp_package);
  }
;
#line 2730 "GetData.xs"
    dtrace("%p, \"%s\", %i, %p, ...[%li]", dirfile, field_code, fragment_index,
        sv_in, (long)items - 4);

    data_in = gdp_convert_strarr(&len, items, ax, 3, gdp_package, "add_sarray");

    RETVAL = gd_add_sarray(dirfile, field_code, len, data_in, fragment_index);

    GDP_UNDEF_ON_ERROR(safefree(data_in));
#line 4198 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2741 "GetData.xs"
    safefree(data_in);
    dreturn("%i", RETVAL);
#line 4203 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_sarray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_sarray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4)
       croak_xs_usage(cv,  "dirfile, parent, field_code, sv_in, ...");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	SV *	sv_in = ST(3)
;
#line 2751 "GetData.xs"
    GDP_DIRFILE_ALIAS;
    size_t len;
    const char **data_in;
#line 4228 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_sarray() - Invalid dirfile object", gdp_package);
  }
;
#line 2757 "GetData.xs"
    dtrace("%p, \"%s\", \"%s\", %p, ...[%li]", dirfile, parent, field_code,
        sv_in, (long)items - 4);

    data_in = gdp_convert_strarr(&len, items, ax, 3, gdp_package,
        "madd_sarray");

    RETVAL = gd_madd_sarray(dirfile, parent, field_code, len, data_in);

    GDP_UNDEF_ON_ERROR(safefree(data_in));
#line 4253 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 2769 "GetData.xs"
    safefree(data_in);
    dreturn("%i", RETVAL);
#line 4258 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_msarrays); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_msarrays)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, parent");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
#line 2777 "GetData.xs"
    int i;
    const char ***data_out = NULL;
    GDP_DIRFILE_ALIAS;
#line 4281 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::msarrays() - Invalid dirfile object", gdp_package);
  }
;
#line 2783 "GetData.xs"
    dtrace("%p, \"%s\"; %i", dirfile, parent, (int)GIMME_V);
    data_out = gd_msarrays(dirfile, parent);

    GDP_UNDEF_ON_ERROR();

    /* in array context, return an array of arrays of strings.
     * Otherwise, return a reference to the same. */
    if (GIMME_V == G_ARRAY)
      for (i = 0; data_out[i]; ++i)
        XPUSHs(sv_2mortal(gdp_newRVavpv0(data_out[i])));
    else {
      AV *av = newAV();
      for (i = 0; data_out[i]; ++i)
        av_store(av, i, gdp_newRVavpv0(data_out[i]));
      XPUSHs(sv_2mortal(newRV_noinc((SV*)av)));
    }

    dreturnvoid();
#line 4313 "GetData.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE:  Including 'simple_funcs.xs' from 'GetData.xs' */


XS_EUPXS(XS_GetData_add_bit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_bit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, bitnum, numbits, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	int	bitnum = (int)SvIV(ST(3))
;
	int	numbits = (int)SvIV(ST(4))
;
	int	fragment_index;
#line 10 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4343 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_bit() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 6)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(5))
;
	}
#line 14 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, %i, %i", dirfile, field_code, in_field, bitnum, numbits, fragment_index);
		RETVAL = gd_add_bit(dirfile, field_code, in_field, bitnum, numbits, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4369 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 20 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4373 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_lincom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_lincom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "dirfile, field_code, n_fields, in_fields, cm, cb, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	n_fields = (int)SvIV(ST(2))
;
	const char **	in_fields;
	gdp_complex_in	cm;
	gdp_complex_in	cb;
	int	fragment_index;
#line 32 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4398 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_lincom() - Invalid dirfile object", gdp_package);
  }
;

  { in_fields = gdp_convert_const_avpv(ST(3), NULL, gdp_package, "add_lincom"); }
;

  if (SvROK(ST(4)) && SvTYPE(SvRV(ST(4))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(4));
    I32 i, len = av_len(av);
    cm = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(cm);
        croak("%s::add_lincom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(cm, i), *sv, NULL, gdp_package,
          "add_lincom");
    }
  } else {
    cm = NULL;
    croak("%s::add_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;

  if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(5));
    I32 i, len = av_len(av);
    cb = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(cb);
        croak("%s::add_lincom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(cb, i), *sv, NULL, gdp_package,
          "add_lincom");
    }
  } else {
    cb = NULL;
    croak("%s::add_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;

	if (items < 7)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(6))
;
	}
#line 36 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, %p, %p, %p, %i", dirfile, field_code, n_fields, in_fields, cm, cb, fragment_index);
		RETVAL = gd_add_clincom(dirfile, field_code, n_fields, in_fields, cm, cb, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4469 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 42 "./simple_funcs.xs"
		safefree(in_fields);
		safefree(cm);
		safefree(cb);
		dreturn("%i", RETVAL);
#line 4476 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_polynom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_polynom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dirfile, field_code, poly_ord, in_field, ca, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	poly_ord = (int)SvIV(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	gdp_complex_in	ca;
	int	fragment_index;
#line 56 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4501 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_polynom() - Invalid dirfile object", gdp_package);
  }
;

  if (SvROK(ST(4)) && SvTYPE(SvRV(ST(4))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(4));
    I32 i, len = av_len(av);
    ca = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(ca);
        croak("%s::add_polynom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(ca, i), *sv, NULL, gdp_package,
          "add_polynom");
    }
  } else {
    ca = NULL;
    croak("%s::add_polynom() - Expected array of complex numbers",
      gdp_package);
  }
;

	if (items < 6)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(5))
;
	}
#line 60 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, \"%s\", %p, %i", dirfile, field_code, poly_ord, in_field, ca, fragment_index);
		RETVAL = gd_add_cpolynom(dirfile, field_code, poly_ord, in_field, ca, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4548 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 66 "./simple_funcs.xs"
		safefree(ca);
		dreturn("%i", RETVAL);
#line 4553 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_recip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_recip)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, cdividend, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	gdp_complex	cdividend;
	int	fragment_index;
#line 77 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4576 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_recip() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(3) == undef)
    gd_rs2cs_(cdividend, 0);
  else
    gdp_convert_cmp(gd_csp_(cdividend), ST(3), NULL, gdp_package, "add_recip")
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 81 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %g;%g, %i", dirfile, field_code, in_field, creal(cdividend), cimag(cdividend), fragment_index);
		RETVAL = gd_add_crecip(dirfile, field_code, in_field, cdividend, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4608 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 87 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4612 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_divide); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_divide)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1, in_field2, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(3))
;
	int	fragment_index;
#line 97 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4636 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_divide() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 101 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field1, in_field2, fragment_index);
		RETVAL = gd_add_divide(dirfile, field_code, in_field1, in_field2, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4662 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 107 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4666 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_linterp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_linterp)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, table, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	const char *	table = (const char *)SvPV_nolen(ST(3))
;
	int	fragment_index;
#line 117 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4690 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_linterp() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 121 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field, table, fragment_index);
		RETVAL = gd_add_linterp(dirfile, field_code, in_field, table, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4716 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 127 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4720 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_multiply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_multiply)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1, in_field2, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(3))
;
	int	fragment_index;
#line 137 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4744 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_multiply() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 141 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field1, in_field2, fragment_index);
		RETVAL = gd_add_multiply(dirfile, field_code, in_field1, in_field2, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4770 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 147 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4774 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_phase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_phase)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, shift, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	gd_int64_t	shift = (gd_int64_t)SvIV(ST(3))
;
	int	fragment_index;
#line 157 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4798 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_phase() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 161 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %" PRId64 ", %i", dirfile, field_code, in_field, shift, fragment_index);
		RETVAL = gd_add_phase(dirfile, field_code, in_field, shift, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4824 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 167 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4828 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_sbit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_sbit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, bitnum, numbits, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	int	bitnum = (int)SvIV(ST(3))
;
	int	numbits = (int)SvIV(ST(4))
;
	int	fragment_index;
#line 178 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4854 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_sbit() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 6)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(5))
;
	}
#line 182 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, %i, %i", dirfile, field_code, in_field, bitnum, numbits, fragment_index);
		RETVAL = gd_add_sbit(dirfile, field_code, in_field, bitnum, numbits, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4880 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 188 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4884 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_string)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, value, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	value = (const char *)SvPV_nolen(ST(2))
;
	int	fragment_index;
#line 197 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4906 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_string() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(3))
;
	}
#line 201 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i", dirfile, field_code, value, fragment_index);
		RETVAL = gd_add_string(dirfile, field_code, value, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 4932 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 207 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 4936 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_bit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_bit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field=NULL, bitnum=-1, numbits=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_ffff_t	bitnum;
	gdp_numbits_t	numbits;
#line 217 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 4958 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_bit() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field = NULL;
	else {
  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    bitnum = -1;
	else {
  if (ST(3) == undef)
    bitnum = (gdp_ffff_t)-1;
  else
    bitnum = (gdp_ffff_t)SvIV(ST(3))
;
	}

	if (items < 5)
	    numbits = 0;
	else {
  if (ST(4) == undef)
    numbits = (gdp_numbits_t)0;
  else
    numbits = (gdp_numbits_t)SvIV(ST(4))
;
	}
#line 221 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, %i", dirfile, field_code, in_field, bitnum, numbits);
		RETVAL = gd_alter_bit(dirfile, field_code, in_field, bitnum, numbits);
		GDP_UNDEF_ON_ERROR();
#line 5007 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 227 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5011 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_carray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_carray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, field_code, const_type, array_len");
    {
	DIRFILE*	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	const_type = (gd_type_t)SvIV(ST(2))
;
	size_t	array_len = (size_t)SvUV(ST(3))
;
#line 236 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5034 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_carray() - Invalid dirfile object", gdp_package);
  }
;
#line 240 "./simple_funcs.xs"
		dtrace("%p, %p, 0x%03X, %" PRIuSIZE "", dirfile, field_code, const_type, array_len);
		RETVAL = gd_alter_carray(dirfile, field_code, const_type, array_len);
		GDP_UNDEF_ON_ERROR();
#line 5053 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 246 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5057 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_lincom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_lincom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 6)
       croak_xs_usage(cv,  "dirfile, field_code, n_fields=0, in_fields=NULL, m=NULL, b=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_int	n_fields;
	const char **	in_fields;
	gdp_complex_undef	m;
	gdp_complex_undef	b;
#line 257 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5080 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_lincom() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    n_fields = 0;
	else {
  if (ST(2) == undef)
    n_fields = (gdp_int)0;
  else
    n_fields = (gdp_int)SvIV(ST(2))
;
	}

	if (items < 4)
	    in_fields = NULL;
	else {
  { in_fields = gdp_convert_const_avpv(ST(3), NULL, gdp_package, "alter_lincom"); }
;
	}

	if (items < 5)
	    m = NULL;
	else {
  if (ST(4) == undef)
    m = NULL;
  else if (SvROK(ST(4)) && SvTYPE(SvRV(ST(4))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(4));
    I32 i, len = av_len(av);
    m = (gdp_complex_undef)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
	safefree(m);
	croak("%s::alter_lincom() - Expected array of complex numbers",
	    gdp_package);
      }
      gdp_convert_cmp(gd_cap_(m, i), *sv, NULL, gdp_package,
	  "alter_lincom");
    }
  } else {
    m = NULL;
    croak("%s::alter_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;
	}

	if (items < 6)
	    b = NULL;
	else {
  if (ST(5) == undef)
    b = NULL;
  else if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(5));
    I32 i, len = av_len(av);
    b = (gdp_complex_undef)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
	safefree(b);
	croak("%s::alter_lincom() - Expected array of complex numbers",
	    gdp_package);
      }
      gdp_convert_cmp(gd_cap_(b, i), *sv, NULL, gdp_package,
	  "alter_lincom");
    }
  } else {
    b = NULL;
    croak("%s::alter_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;
	}
#line 261 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, %p, %p, %p", dirfile, field_code, n_fields, in_fields, m, b);
		RETVAL = gd_alter_clincom(dirfile, field_code, n_fields, in_fields, m, b);
		GDP_UNDEF_ON_ERROR();
#line 5170 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 267 "./simple_funcs.xs"
		safefree(in_fields);
		safefree(m);
		safefree(b);
		dreturn("%i", RETVAL);
#line 5177 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_polynom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_polynom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, poly_ord=0, in_field=NULL, a=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_int	poly_ord;
	gdp_char *	in_field;
	gdp_complex_undef	a;
#line 280 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5199 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_polynom() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    poly_ord = 0;
	else {
  if (ST(2) == undef)
    poly_ord = (gdp_int)0;
  else
    poly_ord = (gdp_int)SvIV(ST(2))
;
	}

	if (items < 4)
	    in_field = NULL;
	else {
  if (ST(3) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    a = NULL;
	else {
  if (ST(4) == undef)
    a = NULL;
  else if (SvROK(ST(4)) && SvTYPE(SvRV(ST(4))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(4));
    I32 i, len = av_len(av);
    a = (gdp_complex_undef)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
	safefree(a);
	croak("%s::alter_polynom() - Expected array of complex numbers",
	    gdp_package);
      }
      gdp_convert_cmp(gd_cap_(a, i), *sv, NULL, gdp_package,
	  "alter_polynom");
    }
  } else {
    a = NULL;
    croak("%s::alter_polynom() - Expected array of complex numbers",
      gdp_package);
  }
;
	}
#line 284 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, \"%s\", %p", dirfile, field_code, poly_ord, in_field, a);
		RETVAL = gd_alter_cpolynom(dirfile, field_code, poly_ord, in_field, a);
		GDP_UNDEF_ON_ERROR();
#line 5265 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 290 "./simple_funcs.xs"
		safefree(a);
		dreturn("%i", RETVAL);
#line 5270 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_recip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_recip)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field=NULL, cdividend");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_complex	cdividend;
#line 300 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5291 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_recip() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field = NULL;
	else {
  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;
	}

  if (ST(3) == undef)
    gd_rs2cs_(cdividend, 0);
  else
    gdp_convert_cmp(gd_csp_(cdividend), ST(3), NULL, gdp_package, "alter_recip")
;
#line 304 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %g;%g", dirfile, field_code, in_field, creal(cdividend), cimag(cdividend));
		RETVAL = gd_alter_crecip(dirfile, field_code, in_field, cdividend);
		GDP_UNDEF_ON_ERROR();
#line 5326 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 310 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5330 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_divide); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_divide)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1=NULL, in_field2=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field1;
	gdp_char *	in_field2;
#line 319 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5351 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_divide() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field1 = NULL;
	else {
  if (ST(2) == undef)
    in_field1 = NULL;
  else
    in_field1 = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    in_field2 = NULL;
	else {
  if (ST(3) == undef)
    in_field2 = NULL;
  else
    in_field2 = SvPV_nolen(ST(3))
;
	}
#line 323 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, field_code, in_field1, in_field2);
		RETVAL = gd_alter_divide(dirfile, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 5390 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 329 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5394 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_multiply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_multiply)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1=NULL, in_field2=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field1;
	gdp_char *	in_field2;
#line 338 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5415 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_multiply() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field1 = NULL;
	else {
  if (ST(2) == undef)
    in_field1 = NULL;
  else
    in_field1 = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    in_field2 = NULL;
	else {
  if (ST(3) == undef)
    in_field2 = NULL;
  else
    in_field2 = SvPV_nolen(ST(3))
;
	}
#line 342 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, field_code, in_field1, in_field2);
		RETVAL = gd_alter_multiply(dirfile, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 5454 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 348 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5458 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_phase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_phase)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, shift");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_int64_t	shift;
#line 357 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5479 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_phase() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;

  if (ST(3) == undef)
    shift = (gdp_int64_t)0;
  else
    shift = (gdp_int64_t)SvIV(ST(3))
;
#line 361 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %" PRId64 "", dirfile, field_code, in_field, shift);
		RETVAL = gd_alter_phase(dirfile, field_code, in_field, shift);
		GDP_UNDEF_ON_ERROR();
#line 5510 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 367 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5514 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_sbit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_sbit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field=NULL, bitnum=-1, numbits=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_ffff_t	bitnum;
	gdp_numbits_t	numbits;
#line 377 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5536 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_sbit() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field = NULL;
	else {
  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    bitnum = -1;
	else {
  if (ST(3) == undef)
    bitnum = (gdp_ffff_t)-1;
  else
    bitnum = (gdp_ffff_t)SvIV(ST(3))
;
	}

	if (items < 5)
	    numbits = 0;
	else {
  if (ST(4) == undef)
    numbits = (gdp_numbits_t)0;
  else
    numbits = (gdp_numbits_t)SvIV(ST(4))
;
	}
#line 381 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, %i", dirfile, field_code, in_field, bitnum, numbits);
		RETVAL = gd_alter_sbit(dirfile, field_code, in_field, bitnum, numbits);
		GDP_UNDEF_ON_ERROR();
#line 5585 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 387 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5589 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_array_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_array_len)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 394 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5608 "GetData.c"
	size_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::array_len() - Invalid dirfile object", gdp_package);
  }
;
#line 398 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_array_len(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 5627 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 404 "./simple_funcs.xs"
		dreturn("%" PRIuSIZE "", RETVAL);
#line 5631 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_encoding); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_encoding)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment");
    {
	DIRFILE *	dirfile;
	int	fragment = (int)SvIV(ST(1))
;
#line 411 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5650 "GetData.c"
	unsigned long int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::encoding() - Invalid dirfile object", gdp_package);
  }
;
#line 415 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment);
		RETVAL = gd_encoding(dirfile, fragment);
		GDP_UNDEF_ON_ERROR();
#line 5669 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 421 "./simple_funcs.xs"
		dreturn("%lu", RETVAL);
#line 5673 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_endianness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_endianness)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment");
    {
	DIRFILE *	dirfile;
	int	fragment = (int)SvIV(ST(1))
;
#line 428 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5692 "GetData.c"
	unsigned long int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::endianness() - Invalid dirfile object", gdp_package);
  }
;
#line 432 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment);
		RETVAL = gd_endianness(dirfile, fragment);
		GDP_UNDEF_ON_ERROR();
#line 5711 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 438 "./simple_funcs.xs"
		dreturn("%lu", RETVAL);
#line 5715 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_fragment_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_fragment_index)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 445 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5734 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::fragment_index() - Invalid dirfile object", gdp_package);
  }
;
#line 449 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_fragment_index(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 5753 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 455 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5757 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_fragmentname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_fragmentname)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, index");
    {
	DIRFILE *	dirfile;
	int	index = (int)SvIV(ST(1))
;
#line 462 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5776 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::fragmentname() - Invalid dirfile object", gdp_package);
  }
;
#line 466 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, index);
		RETVAL = gd_fragmentname(dirfile, index);
		GDP_UNDEF_ON_ERROR();
#line 5795 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 472 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 5799 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, entry, parent");
    {
	DIRFILE *	dirfile;
	gd_entry_t	entry;
	const char *	parent = (const char *)SvPV_nolen(ST(2))
;
#line 480 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5819 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd() - Invalid dirfile object", gdp_package);
  }
;

  gdp_to_entry(&entry, ST(1), NULL, gdp_package, "madd")
;
#line 484 "./simple_funcs.xs"
		dtrace("%p, %p, \"%s\"", dirfile, &entry, parent);
		RETVAL = gd_madd(dirfile, &entry, parent);
		GDP_UNDEF_ON_ERROR();
#line 5841 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 490 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5845 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_bit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_bit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 6)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, bitnum, numbits");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	int	bitnum = (int)SvIV(ST(4))
;
	int	numbits = (int)SvIV(ST(5))
;
#line 501 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5872 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_bit() - Invalid dirfile object", gdp_package);
  }
;
#line 505 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, %i", dirfile, parent, field_code, in_field, bitnum, numbits);
		RETVAL = gd_madd_bit(dirfile, parent, field_code, in_field, bitnum, numbits);
		GDP_UNDEF_ON_ERROR();
#line 5891 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 511 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 5895 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_lincom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_lincom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 7)
       croak_xs_usage(cv,  "dirfile, parent, field_code, n_fields, in_fields, cm, cb");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	int	n_fields = (int)SvIV(ST(3))
;
	const char **	in_fields;
	gdp_complex_in	cm;
	gdp_complex_in	cb;
#line 523 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 5921 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_lincom() - Invalid dirfile object", gdp_package);
  }
;

  { in_fields = gdp_convert_const_avpv(ST(4), NULL, gdp_package, "madd_lincom"); }
;

  if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(5));
    I32 i, len = av_len(av);
    cm = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(cm);
        croak("%s::madd_lincom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(cm, i), *sv, NULL, gdp_package,
          "madd_lincom");
    }
  } else {
    cm = NULL;
    croak("%s::madd_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;

  if (SvROK(ST(6)) && SvTYPE(SvRV(ST(6))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(6));
    I32 i, len = av_len(av);
    cb = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(cb);
        croak("%s::madd_lincom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(cb, i), *sv, NULL, gdp_package,
          "madd_lincom");
    }
  } else {
    cb = NULL;
    croak("%s::madd_lincom() - Expected array of complex numbers",
      gdp_package);
  }
;
#line 527 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, %p, %p, %p", dirfile, parent, field_code, n_fields, in_fields, cm, cb);
		RETVAL = gd_madd_clincom(dirfile, parent, field_code, n_fields, in_fields, cm, cb);
		GDP_UNDEF_ON_ERROR();
#line 5985 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 533 "./simple_funcs.xs"
		safefree(in_fields);
		safefree(cm);
		safefree(cb);
		dreturn("%i", RETVAL);
#line 5992 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_polynom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_polynom)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 6)
       croak_xs_usage(cv,  "dirfile, parent, field_code, poly_ord, in_field, ca");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	int	poly_ord = (int)SvIV(ST(3))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(4))
;
	gdp_complex_in	ca;
#line 547 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6018 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_polynom() - Invalid dirfile object", gdp_package);
  }
;

  if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5))) == SVt_PVAV) {
    AV *av = (AV*)SvRV(ST(5));
    I32 i, len = av_len(av);
    ca = (gdp_complex_in)safemalloc(2 * sizeof(double) * (1 + len));
    for (i = 0; i <= len; ++i) {
      SV **sv = av_fetch(av, i, 0);
      if (sv == NULL) {
        safefree(ca);
        croak("%s::madd_polynom() - Expected array of complex numbers",
            gdp_package);
      }
      gdp_convert_cmp(gd_cap_(ca, i), *sv, NULL, gdp_package,
          "madd_polynom");
    }
  } else {
    ca = NULL;
    croak("%s::madd_polynom() - Expected array of complex numbers",
      gdp_package);
  }
;
#line 551 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i, \"%s\", %p", dirfile, parent, field_code, poly_ord, in_field, ca);
		RETVAL = gd_madd_cpolynom(dirfile, parent, field_code, poly_ord, in_field, ca);
		GDP_UNDEF_ON_ERROR();
#line 6058 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 557 "./simple_funcs.xs"
		safefree(ca);
		dreturn("%i", RETVAL);
#line 6063 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_recip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_recip)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, cdividend");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	gdp_complex	cdividend;
#line 568 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6087 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_recip() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(4) == undef)
    gd_rs2cs_(cdividend, 0);
  else
    gdp_convert_cmp(gd_csp_(cdividend), ST(4), NULL, gdp_package, "madd_recip")
;
#line 572 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %g;%g", dirfile, parent, field_code, in_field, creal(cdividend), cimag(cdividend));
		RETVAL = gd_madd_crecip(dirfile, parent, field_code, in_field, cdividend);
		GDP_UNDEF_ON_ERROR();
#line 6112 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 578 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6116 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_divide); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_divide)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field1, in_field2");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(3))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(4))
;
#line 588 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6141 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_divide() - Invalid dirfile object", gdp_package);
  }
;
#line 592 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, in_field1, in_field2);
		RETVAL = gd_madd_divide(dirfile, parent, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 6160 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 598 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6164 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_linterp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_linterp)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, table");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	const char *	table = (const char *)SvPV_nolen(ST(4))
;
#line 608 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6189 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_linterp() - Invalid dirfile object", gdp_package);
  }
;
#line 612 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, in_field, table);
		RETVAL = gd_madd_linterp(dirfile, parent, field_code, in_field, table);
		GDP_UNDEF_ON_ERROR();
#line 6208 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 618 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6212 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_multiply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_multiply)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field1, in_field2");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(3))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(4))
;
#line 628 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6237 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_multiply() - Invalid dirfile object", gdp_package);
  }
;
#line 632 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, in_field1, in_field2);
		RETVAL = gd_madd_multiply(dirfile, parent, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 6256 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 638 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6260 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_phase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_phase)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, shift");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	gd_int64_t	shift = (gd_int64_t)SvIV(ST(4))
;
#line 648 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6285 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_phase() - Invalid dirfile object", gdp_package);
  }
;
#line 652 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %" PRId64 "", dirfile, parent, field_code, in_field, shift);
		RETVAL = gd_madd_phase(dirfile, parent, field_code, in_field, shift);
		GDP_UNDEF_ON_ERROR();
#line 6304 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 658 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6308 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_sbit); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_sbit)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 6)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, bitnum, numbits");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	int	bitnum = (int)SvIV(ST(4))
;
	int	numbits = (int)SvIV(ST(5))
;
#line 669 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6335 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_sbit() - Invalid dirfile object", gdp_package);
  }
;
#line 673 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, %i", dirfile, parent, field_code, in_field, bitnum, numbits);
		RETVAL = gd_madd_sbit(dirfile, parent, field_code, in_field, bitnum, numbits);
		GDP_UNDEF_ON_ERROR();
#line 6354 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 679 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6358 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_spec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_spec)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, line, parent");
    {
	DIRFILE *	dirfile;
	const char *	line = (const char *)SvPV_nolen(ST(1))
;
	const char *	parent = (const char *)SvPV_nolen(ST(2))
;
#line 687 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6379 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_spec() - Invalid dirfile object", gdp_package);
  }
;
#line 691 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\"", dirfile, line, parent);
		RETVAL = gd_madd_spec(dirfile, line, parent);
		GDP_UNDEF_ON_ERROR();
#line 6398 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 697 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6402 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_string)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, parent, field_code, value");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	value = (const char *)SvPV_nolen(ST(3))
;
#line 706 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6425 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_string() - Invalid dirfile object", gdp_package);
  }
;
#line 710 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, value);
		RETVAL = gd_madd_string(dirfile, parent, field_code, value);
		GDP_UNDEF_ON_ERROR();
#line 6444 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 716 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6448 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_dirfile_standards); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_dirfile_standards)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dirfile, version=GD_VERSION_CURRENT");
    {
	DIRFILE *	dirfile;
	int	version;
#line 723 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6466 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::dirfile_standards() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 2)
	    version = GD_VERSION_CURRENT;
	else {
	    version = (int)SvIV(ST(1))
;
	}
#line 727 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, version);
		RETVAL = gd_dirfile_standards(dirfile, version);
		GDP_UNDEF_ON_ERROR();
#line 6492 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 733 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6496 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_dirfilename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_dirfilename)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 739 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6513 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::dirfilename() - Invalid dirfile object", gdp_package);
  }
;
#line 743 "./simple_funcs.xs"
		dtrace("%p", dirfile);
		RETVAL = gd_dirfilename(dirfile);
		GDP_UNDEF_ON_ERROR();
#line 6532 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 749 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 6536 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_native_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_native_type)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 756 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6555 "GetData.c"
	gd_type_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::native_type() - Invalid dirfile object", gdp_package);
  }
;
#line 760 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_native_type(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 6574 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 766 "./simple_funcs.xs"
		dreturn("0x%03X", RETVAL);
#line 6578 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_parent_fragment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_parent_fragment)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment_index");
    {
	DIRFILE *	dirfile;
	int	fragment_index = (int)SvIV(ST(1))
;
#line 773 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6597 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::parent_fragment() - Invalid dirfile object", gdp_package);
  }
;
#line 777 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment_index);
		RETVAL = gd_parent_fragment(dirfile, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 6616 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 783 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6620 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_protection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_protection)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, protection_level, fragment_index");
    {
	DIRFILE *	dirfile;
	int	protection_level = (int)SvIV(ST(1))
;
	int	fragment_index = (int)SvIV(ST(2))
;
#line 791 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6641 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_protection() - Invalid dirfile object", gdp_package);
  }
;
#line 795 "./simple_funcs.xs"
		dtrace("%p, %i, %i", dirfile, protection_level, fragment_index);
		RETVAL = gd_alter_protection(dirfile, protection_level, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 6660 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 801 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6664 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_protection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_protection)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment_index");
    {
	DIRFILE *	dirfile;
	int	fragment_index = (int)SvIV(ST(1))
;
#line 808 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6683 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::protection() - Invalid dirfile object", gdp_package);
  }
;
#line 812 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment_index);
		RETVAL = gd_protection(dirfile, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 6702 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 818 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6706 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_raw_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_raw_filename)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 825 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6725 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::raw_filename() - Invalid dirfile object", gdp_package);
  }
;
#line 829 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_raw_filename(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 6744 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 835 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 6748 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_reference); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_reference)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dirfile, field_code=NULL");
    {
	DIRFILE *	dirfile;
	gdp_char *	field_code;
#line 842 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6766 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::reference() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 2)
	    field_code = NULL;
	else {
  if (ST(1) == undef)
    field_code = NULL;
  else
    field_code = SvPV_nolen(ST(1))
;
	}
#line 846 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_reference(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 6795 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 852 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 6799 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_spf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_spf)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 859 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6818 "GetData.c"
	unsigned int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::spf() - Invalid dirfile object", gdp_package);
  }
;
#line 863 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_spf(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 6837 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 869 "./simple_funcs.xs"
		dreturn("%u", RETVAL);
#line 6841 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_put_string); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_put_string)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, field_code, data");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	data = (const char *)SvPV_nolen(ST(2))
;
#line 877 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6862 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::put_string() - Invalid dirfile object", gdp_package);
  }
;
#line 881 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\"", dirfile, field_code, data);
		RETVAL = gd_put_string(dirfile, field_code, data);
		GDP_UNDEF_ON_ERROR();
#line 6881 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 887 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6885 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_validate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_validate)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 894 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6904 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::validate() - Invalid dirfile object", gdp_package);
  }
;
#line 898 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_validate(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 6923 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 904 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6927 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, entry");
    {
	DIRFILE *	dirfile;
	gd_entry_t	entry;
#line 911 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6945 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add() - Invalid dirfile object", gdp_package);
  }
;

  gdp_to_entry(&entry, ST(1), NULL, gdp_package, "add")
;
#line 915 "./simple_funcs.xs"
		dtrace("%p, %p", dirfile, &entry);
		RETVAL = gd_add(dirfile, &entry);
		GDP_UNDEF_ON_ERROR();
#line 6967 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 921 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 6971 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_raw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_raw)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, data_type, spf, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_type_t	data_type = (gd_type_t)SvIV(ST(2))
;
	unsigned int	spf = (unsigned int)SvUV(ST(3))
;
	int	fragment_index;
#line 931 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 6995 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_raw() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 935 "./simple_funcs.xs"
		dtrace("%p, \"%s\", 0x%03X, %u, %i", dirfile, field_code, data_type, spf, fragment_index);
		RETVAL = gd_add_raw(dirfile, field_code, data_type, spf, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 7021 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 941 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7025 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_spec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_spec)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, line, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	line = (const char *)SvPV_nolen(ST(1))
;
	int	fragment_index;
#line 949 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7045 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_spec() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(2))
;
	}
#line 953 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i", dirfile, line, fragment_index);
		RETVAL = gd_add_spec(dirfile, line, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 7071 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 959 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7075 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_const); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_const)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, field_code, const_type=GD_NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_type_t	const_type;
#line 967 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7095 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_const() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    const_type = GD_NULL;
	else {
  if (ST(2) == undef)
    const_type = (gdp_type_t)0;
  else
    const_type = (gdp_type_t)SvIV(ST(2))
;
	}
#line 971 "./simple_funcs.xs"
		dtrace("%p, \"%s\", 0x%03X", dirfile, field_code, const_type);
		RETVAL = gd_alter_const(dirfile, field_code, const_type);
		GDP_UNDEF_ON_ERROR();
#line 7124 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 977 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7128 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_encoding); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_encoding)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, encoding, fragment=0, recode=0");
    {
	DIRFILE *	dirfile;
	unsigned long int	encoding = (unsigned long int)SvUV(ST(1))
;
	int	fragment;
	int	recode;
#line 986 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7149 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_encoding() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    fragment = 0;
	else {
	    fragment = (int)SvIV(ST(2))
;
	}

	if (items < 4)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(3))
;
	}
#line 990 "./simple_funcs.xs"
		dtrace("%p, %lu, %i, %i", dirfile, encoding, fragment, recode);
		RETVAL = gd_alter_encoding(dirfile, encoding, fragment, recode);
		GDP_UNDEF_ON_ERROR();
#line 7182 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 996 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7186 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_endianness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_endianness)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, byte_sex, fragment=0, recode=0");
    {
	DIRFILE *	dirfile;
	unsigned long int	byte_sex = (unsigned long int)SvUV(ST(1))
;
	int	fragment;
	int	recode;
#line 1005 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7207 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_endianness() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    fragment = 0;
	else {
	    fragment = (int)SvIV(ST(2))
;
	}

	if (items < 4)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(3))
;
	}
#line 1009 "./simple_funcs.xs"
		dtrace("%p, %lu, %i, %i", dirfile, byte_sex, fragment, recode);
		RETVAL = gd_alter_endianness(dirfile, byte_sex, fragment, recode);
		GDP_UNDEF_ON_ERROR();
#line 7240 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1015 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7244 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_entry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_entry)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, entry, recode=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_pentry_t	entry;
	int	recode;
#line 1024 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7265 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_entry() - Invalid dirfile object", gdp_package);
  }
;

  {
    gd_entry_t old_E;
    if (gd_entry(dirfile, field_code, &old_E)) {
      dreturnvoid();
      XSRETURN_UNDEF;
    }
    gd_free_entry_strings(&old_E);
    gdp_to_entry(&entry, ST(2), &old_E, gdp_package, "alter_entry");
  }
;

	if (items < 4)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(3))
;
	}
#line 1028 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %p, %i", dirfile, field_code, &entry, recode);
		RETVAL = gd_alter_entry(dirfile, field_code, &entry, recode);
		GDP_UNDEF_ON_ERROR();
#line 7302 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1034 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7306 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_linterp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_linterp)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field=NULL, table=NULL, recode=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_char *	table;
	int	recode;
#line 1044 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7328 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_linterp() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field = NULL;
	else {
  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    table = NULL;
	else {
  if (ST(3) == undef)
    table = NULL;
  else
    table = SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(4))
;
	}
#line 1048 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field, table, recode);
		RETVAL = gd_alter_linterp(dirfile, field_code, in_field, table, recode);
		GDP_UNDEF_ON_ERROR();
#line 7374 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1054 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7378 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_raw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_raw)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, data_type=GD_NULL, spf=0, recode=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_type_t	data_type;
	gdp_uint_t	spf;
	int	recode;
#line 1064 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7400 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_raw() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    data_type = GD_NULL;
	else {
  if (ST(2) == undef)
    data_type = (gdp_type_t)0;
  else
    data_type = (gdp_type_t)SvIV(ST(2))
;
	}

	if (items < 4)
	    spf = 0;
	else {
  if (ST(3) == undef)
    spf = (gdp_uint_t)0;
  else
    spf = (gdp_uint_t)SvUV(ST(3))
;
	}

	if (items < 5)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(4))
;
	}
#line 1068 "./simple_funcs.xs"
		dtrace("%p, \"%s\", 0x%03X, %u, %i", dirfile, field_code, data_type, spf, recode);
		RETVAL = gd_alter_raw(dirfile, field_code, data_type, spf, recode);
		GDP_UNDEF_ON_ERROR();
#line 7446 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1074 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7450 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_spec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_spec)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, line, recode=0");
    {
	DIRFILE *	dirfile;
	const char *	line = (const char *)SvPV_nolen(ST(1))
;
	int	recode;
#line 1082 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7470 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_spec() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(2))
;
	}
#line 1086 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i", dirfile, line, recode);
		RETVAL = gd_alter_spec(dirfile, line, recode);
		GDP_UNDEF_ON_ERROR();
#line 7496 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1092 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7500 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_delete)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, field_code, flags=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	flags;
#line 1100 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7520 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::delete() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    flags = 0;
	else {
	    flags = (int)SvIV(ST(2))
;
	}
#line 1104 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i", dirfile, field_code, flags);
		RETVAL = gd_delete(dirfile, field_code, flags);
		GDP_UNDEF_ON_ERROR();
#line 7546 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1110 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7550 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_flush)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1117 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7569 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::flush() - Invalid dirfile object", gdp_package);
  }
;
#line 1121 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_flush(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 7588 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1127 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7592 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_malter_spec); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_malter_spec)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, line, parent, recode=0");
    {
	DIRFILE *	dirfile;
	const char *	line = (const char *)SvPV_nolen(ST(1))
;
	const char *	parent = (const char *)SvPV_nolen(ST(2))
;
	int	recode;
#line 1136 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7614 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::malter_spec() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(3))
;
	}
#line 1140 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i", dirfile, line, parent, recode);
		RETVAL = gd_malter_spec(dirfile, line, parent, recode);
		GDP_UNDEF_ON_ERROR();
#line 7640 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1146 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7644 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_metaflush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_metaflush)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 1152 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7661 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::metaflush() - Invalid dirfile object", gdp_package);
  }
;
#line 1156 "./simple_funcs.xs"
		dtrace("%p", dirfile);
		RETVAL = gd_metaflush(dirfile);
		GDP_UNDEF_ON_ERROR();
#line 7680 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1162 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7684 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_move); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_move)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, new_fragment, flags=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	int	new_fragment = (int)SvIV(ST(2))
;
	unsigned int	flags;
#line 1171 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7706 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::move() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    flags = 0;
	else {
	    flags = (unsigned int)SvUV(ST(3))
;
	}
#line 1175 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, %u", dirfile, field_code, new_fragment, flags);
		RETVAL = gd_move(dirfile, field_code, new_fragment, flags);
		GDP_UNDEF_ON_ERROR();
#line 7732 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1181 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7736 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_rename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_rename)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, old_code, new_name, move_data=0");
    {
	DIRFILE *	dirfile;
	const char *	old_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	new_name = (const char *)SvPV_nolen(ST(2))
;
	int	move_data;
#line 1190 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7758 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::rename() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    move_data = 0;
	else {
	    move_data = (int)SvIV(ST(3))
;
	}
#line 1194 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i", dirfile, old_code, new_name, move_data);
		RETVAL = gd_rename(dirfile, old_code, new_name, move_data);
		GDP_UNDEF_ON_ERROR();
#line 7784 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1200 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7788 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_rewrite_fragment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_rewrite_fragment)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment");
    {
	DIRFILE *	dirfile;
	int	fragment = (int)SvIV(ST(1))
;
#line 1207 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7807 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::rewrite_fragment() - Invalid dirfile object", gdp_package);
  }
;
#line 1211 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment);
		RETVAL = gd_rewrite_fragment(dirfile, fragment);
		GDP_UNDEF_ON_ERROR();
#line 7826 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1217 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7830 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_uninclude); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_uninclude)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, fragment_index, del=0");
    {
	DIRFILE *	dirfile;
	int	fragment_index = (int)SvIV(ST(1))
;
	int	del;
#line 1225 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7850 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::uninclude() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    del = 0;
	else {
	    del = (int)SvIV(ST(2))
;
	}
#line 1229 "./simple_funcs.xs"
		dtrace("%p, %i, %i", dirfile, fragment_index, del);
		RETVAL = gd_uninclude(dirfile, fragment_index, del);
		GDP_UNDEF_ON_ERROR();
#line 7876 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1235 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7880 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_frameoffset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_frameoffset)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, offset, fragment=0, recode=0");
    {
	DIRFILE *	dirfile;
	gd_off64_t	offset = (gd_off64_t)SvIV(ST(1))
;
	int	fragment;
	int	recode;
#line 1244 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7901 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_frameoffset() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    fragment = 0;
	else {
	    fragment = (int)SvIV(ST(2))
;
	}

	if (items < 4)
	    recode = 0;
	else {
	    recode = (int)SvIV(ST(3))
;
	}
#line 1248 "./simple_funcs.xs"
		dtrace("%p, %" PRId64 ", %i, %i", dirfile, (int64_t)offset, fragment, recode);
		RETVAL = gd_alter_frameoffset64(dirfile, offset, fragment, recode);
		GDP_UNDEF_ON_ERROR();
#line 7934 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1254 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 7938 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_frameoffset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_frameoffset)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, fragment");
    {
	DIRFILE *	dirfile;
	int	fragment = (int)SvIV(ST(1))
;
#line 1261 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 7957 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::frameoffset() - Invalid dirfile object", gdp_package);
  }
;
#line 1265 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, fragment);
		RETVAL = gd_frameoffset64(dirfile, fragment);
		GDP_UNDEF_ON_ERROR();
#line 7976 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1271 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 7980 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_framenum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_framenum)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code_in, value, field_start=0, field_end=0");
    {
	DIRFILE *	dirfile;
	const char*	field_code_in = (const char *)SvPV_nolen(ST(1))
;
	double	value = (double)SvNV(ST(2))
;
	gd_off64_t	field_start;
	gd_off64_t	field_end;
#line 1281 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8003 "GetData.c"
	double	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::framenum() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    field_start = 0;
	else {
	    field_start = (gd_off64_t)SvIV(ST(3))
;
	}

	if (items < 5)
	    field_end = 0;
	else {
	    field_end = (gd_off64_t)SvIV(ST(4))
;
	}
#line 1285 "./simple_funcs.xs"
		dtrace("%p, %p, %g, %" PRId64 ", %" PRId64 "", dirfile, field_code_in, value, (int64_t)field_start, (int64_t)field_end);
		RETVAL = gd_framenum_subset64(dirfile, field_code_in, value, field_start, field_end);
		GDP_UNDEF_ON_ERROR();
#line 8036 "GetData.c"
	XSprePUSH; PUSHn((double)RETVAL);
#line 1291 "./simple_funcs.xs"
		dreturn("%g", RETVAL);
#line 8040 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_nframes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_nframes)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 1297 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8057 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::nframes() - Invalid dirfile object", gdp_package);
  }
;
#line 1301 "./simple_funcs.xs"
		dtrace("%p", dirfile);
		RETVAL = gd_nframes64(dirfile);
		GDP_UNDEF_ON_ERROR();
#line 8076 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1307 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 8080 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_bof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_bof)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1314 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8099 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::bof() - Invalid dirfile object", gdp_package);
  }
;
#line 1318 "./simple_funcs.xs"
		dtrace("%p, %p", dirfile, field_code);
		RETVAL = gd_bof64(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8118 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1324 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 8122 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_eof)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1331 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8141 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::eof() - Invalid dirfile object", gdp_package);
  }
;
#line 1335 "./simple_funcs.xs"
		dtrace("%p, %p", dirfile, field_code);
		RETVAL = gd_eof64(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8160 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1341 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 8164 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_error_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_error_count)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 1)
       croak_xs_usage(cv,  "dirfile");
    {
	DIRFILE *	dirfile;
#line 1347 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8181 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::error_count() - Invalid dirfile object", gdp_package);
  }
;
#line 1351 "./simple_funcs.xs"
		dtrace("%p", dirfile);
		RETVAL = gd_error_count(dirfile);
		GDP_UNDEF_ON_ERROR();
#line 8200 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1357 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8204 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_seek); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_seek)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, frame_num, sample_num, flags=GD_SEEK_SET");
    {
	DIRFILE *	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
	gd_off64_t	frame_num = (gd_off64_t)SvIV(ST(2))
;
	gd_off64_t	sample_num = (gd_off64_t)SvIV(ST(3))
;
	int	flags;
#line 1367 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8228 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::seek() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    flags = GD_SEEK_SET;
	else {
	    flags = (int)SvIV(ST(4))
;
	}
#line 1371 "./simple_funcs.xs"
		dtrace("%p, %p, %" PRId64 ", %" PRId64 ", %i", dirfile, field_code, (int64_t)frame_num, (int64_t)sample_num, flags);
		RETVAL = gd_seek(dirfile, field_code, frame_num, sample_num, flags);
		GDP_UNDEF_ON_ERROR();
#line 8254 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1377 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 8258 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_tell); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_tell)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1384 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8277 "GetData.c"
	gd_off64_t	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::tell() - Invalid dirfile object", gdp_package);
  }
;
#line 1388 "./simple_funcs.xs"
		dtrace("%p, %p", dirfile, field_code);
		RETVAL = gd_tell(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8296 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1394 "./simple_funcs.xs"
		dreturn("%" PRId64 "", (int64_t)RETVAL);
#line 8300 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_hide); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_hide)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1401 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8319 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::hide() - Invalid dirfile object", gdp_package);
  }
;
#line 1405 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_hide(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8338 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1411 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8342 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_hidden); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_hidden)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1418 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8361 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::hidden() - Invalid dirfile object", gdp_package);
  }
;
#line 1422 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_hidden(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8380 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1428 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8384 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_unhide); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_unhide)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1435 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8403 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::unhide() - Invalid dirfile object", gdp_package);
  }
;
#line 1439 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_unhide(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8422 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1445 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8426 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_sync); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_sync)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1452 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8445 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::sync() - Invalid dirfile object", gdp_package);
  }
;
#line 1456 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_sync(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8464 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1462 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8468 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alias_target); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alias_target)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1469 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8487 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alias_target() - Invalid dirfile object", gdp_package);
  }
;
#line 1473 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_alias_target(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 8506 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 1479 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 8510 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_alias); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_alias)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, target, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	target = (const char *)SvPV_nolen(ST(2))
;
	int	fragment_index;
#line 1488 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8532 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_alias() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(3))
;
	}
#line 1492 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", %i", dirfile, field_code, target, fragment_index);
		RETVAL = gd_add_alias(dirfile, field_code, target, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 8558 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1498 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8562 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_alias); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_alias)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 4)
       croak_xs_usage(cv,  "dirfile, parent, field_code, target");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	target = (const char *)SvPV_nolen(ST(3))
;
#line 1507 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8585 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_alias() - Invalid dirfile object", gdp_package);
  }
;
#line 1511 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, target);
		RETVAL = gd_madd_alias(dirfile, parent, field_code, target);
		GDP_UNDEF_ON_ERROR();
#line 8604 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1517 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8608 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_window); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_window)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, check_field, windop, threshold, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	const char *	check_field = (const char *)SvPV_nolen(ST(3))
;
	gd_windop_t	windop = (gd_windop_t)SvIV(ST(4))
;
	gd_triplet_t	threshold;
	int	fragment_index;
#line 1529 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8635 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_window() - Invalid dirfile object", gdp_package);
  }
;

  { switch (windop) {
    case GD_WINDOP_EQ:
    case GD_WINDOP_NE:
      threshold.i = (int64_t)SvIV(ST(5));
      break;
    case GD_WINDOP_SET:
    case GD_WINDOP_CLR:
      threshold.u = (uint64_t)SvUV(ST(5));
      break;
    default:
      threshold.r = SvNV(ST(5));
      break;
  }}
;

	if (items < 7)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(6))
;
	}
#line 1533 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, {%g,%" PRIX64 ",%" PRId64 "}, %i", dirfile, field_code, in_field, check_field, windop, threshold.r, threshold.u, threshold.i, fragment_index);
		RETVAL = gd_add_window(dirfile, field_code, in_field, check_field, windop, threshold, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 8676 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1539 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8680 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_window); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_window)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 7)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, check_field, windop, threshold");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	const char *	check_field = (const char *)SvPV_nolen(ST(4))
;
	gd_windop_t	windop = (gd_windop_t)SvIV(ST(5))
;
	gd_triplet_t	threshold;
#line 1551 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8708 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_window() - Invalid dirfile object", gdp_package);
  }
;

  { switch (windop) {
    case GD_WINDOP_EQ:
    case GD_WINDOP_NE:
      threshold.i = (int64_t)SvIV(ST(6));
      break;
    case GD_WINDOP_SET:
    case GD_WINDOP_CLR:
      threshold.u = (uint64_t)SvUV(ST(6));
      break;
    default:
      threshold.r = SvNV(ST(6));
      break;
  }}
;
#line 1555 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\", %i, {%g,%" PRIX64 ",%" PRId64 "}", dirfile, parent, field_code, in_field, check_field, windop, threshold.r, threshold.u, threshold.i);
		RETVAL = gd_madd_window(dirfile, parent, field_code, in_field, check_field, windop, threshold);
		GDP_UNDEF_ON_ERROR();
#line 8742 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1561 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8746 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_window); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_window)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 6)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, check_field, windop, threshold");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_char *	check_field;
	gd_windop_t	windop = (gd_windop_t)SvIV(ST(4))
;
	gd_triplet_t	threshold;
#line 1572 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8770 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_window() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;

  if (ST(3) == undef)
    check_field = NULL;
  else
    check_field = SvPV_nolen(ST(3))
;

  { switch (windop) {
    case GD_WINDOP_EQ:
    case GD_WINDOP_NE:
      threshold.i = (int64_t)SvIV(ST(5));
      break;
    case GD_WINDOP_SET:
    case GD_WINDOP_CLR:
      threshold.u = (uint64_t)SvUV(ST(5));
      break;
    default:
      threshold.r = SvNV(ST(5));
      break;
  }}
;
#line 1576 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, {%g,%" PRIX64 ",%" PRId64 "}", dirfile, field_code, in_field, check_field, windop, threshold.r, threshold.u, threshold.i);
		RETVAL = gd_alter_window(dirfile, field_code, in_field, check_field, windop, threshold);
		GDP_UNDEF_ON_ERROR();
#line 8816 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1582 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8820 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_affixes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_affixes)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "dirfile, index, prefix, suffix=NULL");
    {
	DIRFILE *	dirfile;
	int	index = (int)SvIV(ST(1))
;
	gdp_char *	prefix;
	gdp_char *	suffix;
#line 1591 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8841 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_affixes() - Invalid dirfile object", gdp_package);
  }
;

  if (ST(2) == undef)
    prefix = NULL;
  else
    prefix = SvPV_nolen(ST(2))
;

	if (items < 4)
	    suffix = NULL;
	else {
  if (ST(3) == undef)
    suffix = NULL;
  else
    suffix = SvPV_nolen(ST(3))
;
	}
#line 1595 "./simple_funcs.xs"
		dtrace("%p, %i, \"%s\", \"%s\"", dirfile, index, prefix, suffix);
		RETVAL = gd_alter_affixes(dirfile, index, prefix, suffix);
		GDP_UNDEF_ON_ERROR();
#line 8876 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1601 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8880 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_mplex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_mplex)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "dirfile, field_code, in_field, count_field, count_val, period, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(2))
;
	const char *	count_field = (const char *)SvPV_nolen(ST(3))
;
	int	count_val = (int)SvIV(ST(4))
;
	int	period = (int)SvIV(ST(5))
;
	int	fragment_index;
#line 1613 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8908 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_mplex() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 7)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(6))
;
	}
#line 1617 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, %i, %i", dirfile, field_code, in_field, count_field, count_val, period, fragment_index);
		RETVAL = gd_add_mplex(dirfile, field_code, in_field, count_field, count_val, period, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 8934 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1623 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 8938 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_mplex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_mplex)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 6)
       croak_xs_usage(cv,  "dirfile, field_code, in_field=NULL, count_field=NULL, count_val=-1, period=-1");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field;
	gdp_char *	count_field;
	int	count_val;
	int	period;
#line 1634 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 8961 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_mplex() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field = NULL;
	else {
  if (ST(2) == undef)
    in_field = NULL;
  else
    in_field = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    count_field = NULL;
	else {
  if (ST(3) == undef)
    count_field = NULL;
  else
    count_field = SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    count_val = -1;
	else {
	    count_val = (int)SvIV(ST(4))
;
	}

	if (items < 6)
	    period = -1;
	else {
	    period = (int)SvIV(ST(5))
;
	}
#line 1638 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i, %i", dirfile, field_code, in_field, count_field, count_val, period);
		RETVAL = gd_alter_mplex(dirfile, field_code, in_field, count_field, count_val, period);
		GDP_UNDEF_ON_ERROR();
#line 9014 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1644 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9018 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_mplex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_mplex)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 7)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field, count_field, count_val, period");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field = (const char *)SvPV_nolen(ST(3))
;
	const char *	count_field = (const char *)SvPV_nolen(ST(4))
;
	int	count_val = (int)SvIV(ST(5))
;
	int	period = (int)SvIV(ST(6))
;
#line 1656 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9047 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_mplex() - Invalid dirfile object", gdp_package);
  }
;
#line 1660 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\", %i, %i", dirfile, parent, field_code, in_field, count_field, count_val, period);
		RETVAL = gd_madd_mplex(dirfile, parent, field_code, in_field, count_field, count_val, period);
		GDP_UNDEF_ON_ERROR();
#line 9066 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1666 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9070 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_raw_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_raw_close)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1673 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9089 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::raw_close() - Invalid dirfile object", gdp_package);
  }
;
#line 1677 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_raw_close(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 9108 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1683 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9112 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_desync); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_desync)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dirfile, flags=0");
    {
	DIRFILE *	dirfile;
	unsigned int	flags;
#line 1690 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9130 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::desync() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 2)
	    flags = 0;
	else {
	    flags = (unsigned int)SvUV(ST(1))
;
	}
#line 1694 "./simple_funcs.xs"
		dtrace("%p, %u", dirfile, flags);
		RETVAL = gd_desync(dirfile, flags);
		GDP_UNDEF_ON_ERROR();
#line 9156 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1700 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9160 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_flags); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_flags)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "dirfile, set=0, reset=0");
    {
	DIRFILE *	dirfile;
	unsigned long int	set;
	unsigned long int	reset;
#line 1708 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9179 "GetData.c"
	unsigned long int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::flags() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 2)
	    set = 0;
	else {
	    set = (unsigned long int)SvUV(ST(1))
;
	}

	if (items < 3)
	    reset = 0;
	else {
	    reset = (unsigned long int)SvUV(ST(2))
;
	}
#line 1712 "./simple_funcs.xs"
		dtrace("%p, %lu, %lu", dirfile, set, reset);
		RETVAL = gd_flags(dirfile, set, reset);
		GDP_UNDEF_ON_ERROR();
#line 9212 "GetData.c"
	XSprePUSH; PUSHu((UV)RETVAL);
#line 1718 "./simple_funcs.xs"
		dreturn("%lu", RETVAL);
#line 9216 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_verbose_prefix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_verbose_prefix)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "dirfile, prefix=NULL");
    {
	DIRFILE *	dirfile;
	gdp_char *	prefix;
#line 1725 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9234 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::verbose_prefix() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 2)
	    prefix = NULL;
	else {
  if (ST(1) == undef)
    prefix = NULL;
  else
    prefix = SvPV_nolen(ST(1))
;
	}
#line 1729 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, prefix);
		RETVAL = gd_verbose_prefix(dirfile, prefix);
		GDP_UNDEF_ON_ERROR();
#line 9263 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1735 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9267 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_mplex_lookback); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_mplex_lookback)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, lookback");
    {
	DIRFILE *	dirfile;
	int	lookback = (int)SvIV(ST(1))
;
#line 1742 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9286 "GetData.c"

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::mplex_lookback() - Invalid dirfile object", gdp_package);
  }
;
#line 1746 "./simple_funcs.xs"
		dtrace("%p, %i", dirfile, lookback);
		gd_mplex_lookback(dirfile, lookback);
#line 9302 "GetData.c"
#line 1749 "./simple_funcs.xs"
		dreturnvoid();
#line 9305 "GetData.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_GetData_linterp_tablename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_linterp_tablename)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 2)
       croak_xs_usage(cv,  "dirfile, field_code");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
#line 1756 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9324 "GetData.c"
	char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::linterp_tablename() - Invalid dirfile object", gdp_package);
  }
;
#line 1760 "./simple_funcs.xs"
		dtrace("%p, \"%s\"", dirfile, field_code);
		RETVAL = gd_linterp_tablename(dirfile, field_code);
		GDP_UNDEF_ON_ERROR();
#line 9343 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 1766 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
		safefree(RETVAL);
#line 9348 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_sarray); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_sarray)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 3)
       croak_xs_usage(cv,  "dirfile, field_code, array_len");
    {
	DIRFILE*	dirfile;
	const char*	field_code = (const char *)SvPV_nolen(ST(1))
;
	size_t	array_len = (size_t)SvUV(ST(2))
;
#line 1775 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9369 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_sarray() - Invalid dirfile object", gdp_package);
  }
;
#line 1779 "./simple_funcs.xs"
		dtrace("%p, %p, %" PRIuSIZE "", dirfile, field_code, array_len);
		RETVAL = gd_alter_sarray(dirfile, field_code, array_len);
		GDP_UNDEF_ON_ERROR();
#line 9388 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1785 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9392 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_indir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_indir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1, in_field2, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(3))
;
	int	fragment_index;
#line 1795 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9416 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_indir() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 1799 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field1, in_field2, fragment_index);
		RETVAL = gd_add_indir(dirfile, field_code, in_field1, in_field2, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 9442 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1805 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9446 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_add_sindir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_add_sindir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 4 || items > 5)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1, in_field2, fragment_index=0");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(3))
;
	int	fragment_index;
#line 1815 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9470 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::add_sindir() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 5)
	    fragment_index = 0;
	else {
	    fragment_index = (int)SvIV(ST(4))
;
	}
#line 1819 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", %i", dirfile, field_code, in_field1, in_field2, fragment_index);
		RETVAL = gd_add_sindir(dirfile, field_code, in_field1, in_field2, fragment_index);
		GDP_UNDEF_ON_ERROR();
#line 9496 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1825 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9500 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_indir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_indir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1=NULL, in_field2=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field1;
	gdp_char *	in_field2;
#line 1834 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9521 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_indir() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field1 = NULL;
	else {
  if (ST(2) == undef)
    in_field1 = NULL;
  else
    in_field1 = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    in_field2 = NULL;
	else {
  if (ST(3) == undef)
    in_field2 = NULL;
  else
    in_field2 = SvPV_nolen(ST(3))
;
	}
#line 1838 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, field_code, in_field1, in_field2);
		RETVAL = gd_alter_indir(dirfile, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 9560 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1844 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9564 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_alter_sindir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_alter_sindir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "dirfile, field_code, in_field1=NULL, in_field2=NULL");
    {
	DIRFILE *	dirfile;
	const char *	field_code = (const char *)SvPV_nolen(ST(1))
;
	gdp_char *	in_field1;
	gdp_char *	in_field2;
#line 1853 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9585 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::alter_sindir() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    in_field1 = NULL;
	else {
  if (ST(2) == undef)
    in_field1 = NULL;
  else
    in_field1 = SvPV_nolen(ST(2))
;
	}

	if (items < 4)
	    in_field2 = NULL;
	else {
  if (ST(3) == undef)
    in_field2 = NULL;
  else
    in_field2 = SvPV_nolen(ST(3))
;
	}
#line 1857 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\"", dirfile, field_code, in_field1, in_field2);
		RETVAL = gd_alter_sindir(dirfile, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 9624 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1863 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9628 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_indir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_indir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field1, in_field2");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(3))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(4))
;
#line 1873 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9653 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_indir() - Invalid dirfile object", gdp_package);
  }
;
#line 1877 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, in_field1, in_field2);
		RETVAL = gd_madd_indir(dirfile, parent, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 9672 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1883 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9676 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_madd_sindir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_madd_sindir)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 5)
       croak_xs_usage(cv,  "dirfile, parent, field_code, in_field1, in_field2");
    {
	DIRFILE *	dirfile;
	const char *	parent = (const char *)SvPV_nolen(ST(1))
;
	const char *	field_code = (const char *)SvPV_nolen(ST(2))
;
	const char *	in_field1 = (const char *)SvPV_nolen(ST(3))
;
	const char *	in_field2 = (const char *)SvPV_nolen(ST(4))
;
#line 1893 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9701 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::madd_sindir() - Invalid dirfile object", gdp_package);
  }
;
#line 1897 "./simple_funcs.xs"
		dtrace("%p, \"%s\", \"%s\", \"%s\", \"%s\"", dirfile, parent, field_code, in_field1, in_field2);
		RETVAL = gd_madd_sindir(dirfile, parent, field_code, in_field1, in_field2);
		GDP_UNDEF_ON_ERROR();
#line 9720 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1903 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9724 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_include_affix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_include_affix)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 3 || items > 6)
       croak_xs_usage(cv,  "dirfile, file, fragment_index, prefix=NULL, suffix=NULL, flags=0");
    {
	DIRFILE *	dirfile;
	const char *	file = (const char *)SvPV_nolen(ST(1))
;
	int	fragment_index = (int)SvIV(ST(2))
;
	gdp_char *	prefix;
	gdp_char *	suffix;
	unsigned long int	flags;
#line 1914 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9748 "GetData.c"
	int	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::include_affix() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 4)
	    prefix = NULL;
	else {
  if (ST(3) == undef)
    prefix = NULL;
  else
    prefix = SvPV_nolen(ST(3))
;
	}

	if (items < 5)
	    suffix = NULL;
	else {
  if (ST(4) == undef)
    suffix = NULL;
  else
    suffix = SvPV_nolen(ST(4))
;
	}

	if (items < 6)
	    flags = 0;
	else {
	    flags = (unsigned long int)SvUV(ST(5))
;
	}
#line 1918 "./simple_funcs.xs"
		dtrace("%p, \"%s\", %i, \"%s\", \"%s\", %lu", dirfile, file, fragment_index, prefix, suffix, flags);
		RETVAL = gd_include_affix(dirfile, file, fragment_index, prefix, suffix, flags);
		GDP_UNDEF_ON_ERROR();
#line 9794 "GetData.c"
	XSprePUSH; PUSHi((IV)RETVAL);
#line 1924 "./simple_funcs.xs"
		dreturn("%i", RETVAL);
#line 9798 "GetData.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_GetData_fragment_namespace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_GetData_fragment_namespace)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "dirfile, fragment, namespace=NULL");
    {
	DIRFILE *	dirfile;
	int	fragment = (int)SvIV(ST(1))
;
	gdp_char *	namespace;
#line 1932 "./simple_funcs.xs"
		GDP_DIRFILE_ALIAS;
#line 9818 "GetData.c"
	const char *	RETVAL;
	dXSTARG;

  {
    struct gdp_dirfile_t *gdp_dirfile;
    if (sv_isa(ST(0), "GetData::Dirfile")) {
      gdp_dirfile = INT2PTR(struct gdp_dirfile_t*, SvIV((SV*)SvRV(ST(0))));
      dirfile = gdp_dirfile->D;
      if (dirfile == NULL)
        dirfile = gdp_invalid;
    } else
      croak("%s::fragment_namespace() - Invalid dirfile object", gdp_package);
  }
;

	if (items < 3)
	    namespace = NULL;
	else {
  if (ST(2) == undef)
    namespace = NULL;
  else
    namespace = SvPV_nolen(ST(2))
;
	}
#line 1936 "./simple_funcs.xs"
		dtrace("%p, %i, \"%s\"", dirfile, fragment, namespace);
		RETVAL = gd_fragment_namespace(dirfile, fragment, namespace);
		GDP_UNDEF_ON_ERROR();
#line 9847 "GetData.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
#line 1942 "./simple_funcs.xs"
		dreturn("\"%s\"", RETVAL);
#line 9851 "GetData.c"
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'GetData.xs' from 'simple_funcs.xs' */

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_GetData); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_GetData)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

    {
        CV * cv;

        cv = newXSproto_portable("GetData::DESTROY", XS_GetData_DESTROY, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::DESTROY", XS_GetData_DESTROY, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::error", XS_GetData_error, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::error", XS_GetData_error, file, "$");
        XSANY.any_i32 = 1;
        (void)newXSproto_portable("GetData::open", XS_GetData_open, file, "$$;$$");
        (void)newXSproto_portable("GetData::invalid_dirfile", XS_GetData_invalid_dirfile, file, "");
        cv = newXSproto_portable("GetData::Dirfile::get_carray", XS_GetData_get_carray, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::get_carray", XS_GetData_get_carray, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::get_carray_slice", XS_GetData_get_carray_slice, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::get_carray_slice", XS_GetData_get_carray_slice, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::get_constant", XS_GetData_get_constant, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::get_constant", XS_GetData_get_constant, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::constants", XS_GetData_constants, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::constants", XS_GetData_constants, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::carrays", XS_GetData_carrays, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::carrays", XS_GetData_carrays, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::entry", XS_GetData_entry, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::entry", XS_GetData_entry, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::error_string", XS_GetData_error_string, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::error_string", XS_GetData_error_string, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::mcarrays", XS_GetData_mcarrays, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mcarrays", XS_GetData_mcarrays, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::mconstants", XS_GetData_mconstants, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::mconstants", XS_GetData_mconstants, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::parser_callback", XS_GetData_parser_callback, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::parser_callback", XS_GetData_parser_callback, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::get_string", XS_GetData_get_string, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::get_string", XS_GetData_get_string, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::close", XS_GetData_close, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::close", XS_GetData_close, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::discard", XS_GetData_discard, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::discard", XS_GetData_discard, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::getdata", XS_GetData_getdata, file, "$$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::getdata", XS_GetData_getdata, file, "$$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::field_list", XS_GetData_field_list, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::field_list", XS_GetData_field_list, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::field_list_by_type", XS_GetData_field_list_by_type, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::field_list_by_type", XS_GetData_field_list_by_type, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::entry_list", XS_GetData_entry_list, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::entry_list", XS_GetData_entry_list, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::match_entries", XS_GetData_match_entries, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::match_entries", XS_GetData_match_entries, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::vector_list", XS_GetData_vector_list, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::vector_list", XS_GetData_vector_list, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::strings", XS_GetData_strings, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::strings", XS_GetData_strings, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::mfield_list", XS_GetData_mfield_list, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mfield_list", XS_GetData_mfield_list, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::mfield_list_by_type", XS_GetData_mfield_list_by_type, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mfield_list_by_type", XS_GetData_mfield_list_by_type, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::mvector_list", XS_GetData_mvector_list, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mvector_list", XS_GetData_mvector_list, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::mstrings", XS_GetData_mstrings, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mstrings", XS_GetData_mstrings, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::put_carray", XS_GetData_put_carray, file, "$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::put_carray", XS_GetData_put_carray, file, "$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::put_carray_slice", XS_GetData_put_carray_slice, file, "$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::put_carray_slice", XS_GetData_put_carray_slice, file, "$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::add_carray", XS_GetData_add_carray, file, "$$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_carray", XS_GetData_add_carray, file, "$$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_carray", XS_GetData_madd_carray, file, "$$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_carray", XS_GetData_madd_carray, file, "$$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::putdata", XS_GetData_putdata, file, "$$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::putdata", XS_GetData_putdata, file, "$$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_const", XS_GetData_add_const, file, "$$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_const", XS_GetData_add_const, file, "$$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::madd_const", XS_GetData_madd_const, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_const", XS_GetData_madd_const, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::put_constant", XS_GetData_put_constant, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::put_constant", XS_GetData_put_constant, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::fragments", XS_GetData_fragments, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::fragments", XS_GetData_fragments, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::aliases", XS_GetData_aliases, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::aliases", XS_GetData_aliases, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::fragment_affixes", XS_GetData_fragment_affixes, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::fragment_affixes", XS_GetData_fragment_affixes, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::strtok", XS_GetData_strtok, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::strtok", XS_GetData_strtok, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::include", XS_GetData_include, file, "$$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::include", XS_GetData_include, file, "$$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::carray_len", XS_GetData_carray_len, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::carray_len", XS_GetData_carray_len, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::get_sarray", XS_GetData_get_sarray, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::get_sarray", XS_GetData_get_sarray, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::get_sarray_slice", XS_GetData_get_sarray_slice, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::get_sarray_slice", XS_GetData_get_sarray_slice, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::sarrays", XS_GetData_sarrays, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::sarrays", XS_GetData_sarrays, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::put_sarray", XS_GetData_put_sarray, file, "$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::put_sarray", XS_GetData_put_sarray, file, "$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::put_sarray_slice", XS_GetData_put_sarray_slice, file, "$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::put_sarray_slice", XS_GetData_put_sarray_slice, file, "$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_sarray", XS_GetData_add_sarray, file, "$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_sarray", XS_GetData_add_sarray, file, "$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_sarray", XS_GetData_madd_sarray, file, "$$$$;@");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_sarray", XS_GetData_madd_sarray, file, "$$$$;@");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::msarrays", XS_GetData_msarrays, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::msarrays", XS_GetData_msarrays, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add_bit", XS_GetData_add_bit, file, "$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_bit", XS_GetData_add_bit, file, "$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_lincom", XS_GetData_add_lincom, file, "$$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_lincom", XS_GetData_add_lincom, file, "$$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::add_polynom", XS_GetData_add_polynom, file, "$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_polynom", XS_GetData_add_polynom, file, "$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_recip", XS_GetData_add_recip, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_recip", XS_GetData_add_recip, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add_divide", XS_GetData_add_divide, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_divide", XS_GetData_add_divide, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_linterp", XS_GetData_add_linterp, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_linterp", XS_GetData_add_linterp, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_multiply", XS_GetData_add_multiply, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_multiply", XS_GetData_add_multiply, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_phase", XS_GetData_add_phase, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_phase", XS_GetData_add_phase, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_sbit", XS_GetData_add_sbit, file, "$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_sbit", XS_GetData_add_sbit, file, "$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::add_string", XS_GetData_add_string, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_string", XS_GetData_add_string, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_bit", XS_GetData_alter_bit, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_bit", XS_GetData_alter_bit, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_carray", XS_GetData_alter_carray, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_carray", XS_GetData_alter_carray, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_lincom", XS_GetData_alter_lincom, file, "$$;$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_lincom", XS_GetData_alter_lincom, file, "$$;$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_polynom", XS_GetData_alter_polynom, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_polynom", XS_GetData_alter_polynom, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_recip", XS_GetData_alter_recip, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_recip", XS_GetData_alter_recip, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_divide", XS_GetData_alter_divide, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_divide", XS_GetData_alter_divide, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_multiply", XS_GetData_alter_multiply, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_multiply", XS_GetData_alter_multiply, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_phase", XS_GetData_alter_phase, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_phase", XS_GetData_alter_phase, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_sbit", XS_GetData_alter_sbit, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_sbit", XS_GetData_alter_sbit, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::array_len", XS_GetData_array_len, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::array_len", XS_GetData_array_len, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::encoding", XS_GetData_encoding, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::encoding", XS_GetData_encoding, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::endianness", XS_GetData_endianness, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::endianness", XS_GetData_endianness, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::fragment_index", XS_GetData_fragment_index, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::fragment_index", XS_GetData_fragment_index, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::fragmentname", XS_GetData_fragmentname, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::fragmentname", XS_GetData_fragmentname, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::madd", XS_GetData_madd, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd", XS_GetData_madd, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_bit", XS_GetData_madd_bit, file, "$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_bit", XS_GetData_madd_bit, file, "$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_lincom", XS_GetData_madd_lincom, file, "$$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_lincom", XS_GetData_madd_lincom, file, "$$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_polynom", XS_GetData_madd_polynom, file, "$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_polynom", XS_GetData_madd_polynom, file, "$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_recip", XS_GetData_madd_recip, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_recip", XS_GetData_madd_recip, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::madd_divide", XS_GetData_madd_divide, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_divide", XS_GetData_madd_divide, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_linterp", XS_GetData_madd_linterp, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_linterp", XS_GetData_madd_linterp, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_multiply", XS_GetData_madd_multiply, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_multiply", XS_GetData_madd_multiply, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::madd_phase", XS_GetData_madd_phase, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_phase", XS_GetData_madd_phase, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_sbit", XS_GetData_madd_sbit, file, "$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_sbit", XS_GetData_madd_sbit, file, "$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_spec", XS_GetData_madd_spec, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_spec", XS_GetData_madd_spec, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_string", XS_GetData_madd_string, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_string", XS_GetData_madd_string, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::dirfile_standards", XS_GetData_dirfile_standards, file, "$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::dirfile_standards", XS_GetData_dirfile_standards, file, "$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::dirfilename", XS_GetData_dirfilename, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::dirfilename", XS_GetData_dirfilename, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::native_type", XS_GetData_native_type, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::native_type", XS_GetData_native_type, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::parent_fragment", XS_GetData_parent_fragment, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::parent_fragment", XS_GetData_parent_fragment, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_protection", XS_GetData_alter_protection, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_protection", XS_GetData_alter_protection, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::protection", XS_GetData_protection, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::protection", XS_GetData_protection, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::raw_filename", XS_GetData_raw_filename, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::raw_filename", XS_GetData_raw_filename, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::reference", XS_GetData_reference, file, "$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::reference", XS_GetData_reference, file, "$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::spf", XS_GetData_spf, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::spf", XS_GetData_spf, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::put_string", XS_GetData_put_string, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::put_string", XS_GetData_put_string, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::validate", XS_GetData_validate, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::validate", XS_GetData_validate, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add", XS_GetData_add, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add", XS_GetData_add, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::add_raw", XS_GetData_add_raw, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_raw", XS_GetData_add_raw, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add_spec", XS_GetData_add_spec, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_spec", XS_GetData_add_spec, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_const", XS_GetData_alter_const, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_const", XS_GetData_alter_const, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_encoding", XS_GetData_alter_encoding, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_encoding", XS_GetData_alter_encoding, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_endianness", XS_GetData_alter_endianness, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_endianness", XS_GetData_alter_endianness, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_entry", XS_GetData_alter_entry, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_entry", XS_GetData_alter_entry, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_linterp", XS_GetData_alter_linterp, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_linterp", XS_GetData_alter_linterp, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_raw", XS_GetData_alter_raw, file, "$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_raw", XS_GetData_alter_raw, file, "$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_spec", XS_GetData_alter_spec, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_spec", XS_GetData_alter_spec, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::delete", XS_GetData_delete, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::delete", XS_GetData_delete, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::flush", XS_GetData_flush, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::flush", XS_GetData_flush, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::malter_spec", XS_GetData_malter_spec, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::malter_spec", XS_GetData_malter_spec, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::metaflush", XS_GetData_metaflush, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::metaflush", XS_GetData_metaflush, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::move", XS_GetData_move, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::move", XS_GetData_move, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::rename", XS_GetData_rename, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::rename", XS_GetData_rename, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::rewrite_fragment", XS_GetData_rewrite_fragment, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::rewrite_fragment", XS_GetData_rewrite_fragment, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::uninclude", XS_GetData_uninclude, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::uninclude", XS_GetData_uninclude, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_frameoffset", XS_GetData_alter_frameoffset, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_frameoffset", XS_GetData_alter_frameoffset, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::frameoffset", XS_GetData_frameoffset, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::frameoffset", XS_GetData_frameoffset, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::framenum", XS_GetData_framenum, file, "$$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::framenum", XS_GetData_framenum, file, "$$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::nframes", XS_GetData_nframes, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::nframes", XS_GetData_nframes, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::bof", XS_GetData_bof, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::bof", XS_GetData_bof, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::eof", XS_GetData_eof, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::eof", XS_GetData_eof, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::error_count", XS_GetData_error_count, file, "$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::error_count", XS_GetData_error_count, file, "$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::seek", XS_GetData_seek, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::seek", XS_GetData_seek, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::tell", XS_GetData_tell, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::tell", XS_GetData_tell, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::hide", XS_GetData_hide, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::hide", XS_GetData_hide, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::hidden", XS_GetData_hidden, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::hidden", XS_GetData_hidden, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::unhide", XS_GetData_unhide, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::unhide", XS_GetData_unhide, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::sync", XS_GetData_sync, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::sync", XS_GetData_sync, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alias_target", XS_GetData_alias_target, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alias_target", XS_GetData_alias_target, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::add_alias", XS_GetData_add_alias, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_alias", XS_GetData_add_alias, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_alias", XS_GetData_madd_alias, file, "$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_alias", XS_GetData_madd_alias, file, "$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add_window", XS_GetData_add_window, file, "$$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_window", XS_GetData_add_window, file, "$$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::madd_window", XS_GetData_madd_window, file, "$$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_window", XS_GetData_madd_window, file, "$$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::alter_window", XS_GetData_alter_window, file, "$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_window", XS_GetData_alter_window, file, "$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_affixes", XS_GetData_alter_affixes, file, "$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_affixes", XS_GetData_alter_affixes, file, "$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::add_mplex", XS_GetData_add_mplex, file, "$$$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_mplex", XS_GetData_add_mplex, file, "$$$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_mplex", XS_GetData_alter_mplex, file, "$$;$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_mplex", XS_GetData_alter_mplex, file, "$$;$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_mplex", XS_GetData_madd_mplex, file, "$$$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_mplex", XS_GetData_madd_mplex, file, "$$$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::raw_close", XS_GetData_raw_close, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::raw_close", XS_GetData_raw_close, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::desync", XS_GetData_desync, file, "$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::desync", XS_GetData_desync, file, "$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::flags", XS_GetData_flags, file, "$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::flags", XS_GetData_flags, file, "$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::verbose_prefix", XS_GetData_verbose_prefix, file, "$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::verbose_prefix", XS_GetData_verbose_prefix, file, "$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::mplex_lookback", XS_GetData_mplex_lookback, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::mplex_lookback", XS_GetData_mplex_lookback, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::linterp_tablename", XS_GetData_linterp_tablename, file, "$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::linterp_tablename", XS_GetData_linterp_tablename, file, "$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_sarray", XS_GetData_alter_sarray, file, "$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_sarray", XS_GetData_alter_sarray, file, "$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_indir", XS_GetData_add_indir, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_indir", XS_GetData_add_indir, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::add_sindir", XS_GetData_add_sindir, file, "$$$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::add_sindir", XS_GetData_add_sindir, file, "$$$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::alter_indir", XS_GetData_alter_indir, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_indir", XS_GetData_alter_indir, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::alter_sindir", XS_GetData_alter_sindir, file, "$$;$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::alter_sindir", XS_GetData_alter_sindir, file, "$$;$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_indir", XS_GetData_madd_indir, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::madd_indir", XS_GetData_madd_indir, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::madd_sindir", XS_GetData_madd_sindir, file, "$$$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::madd_sindir", XS_GetData_madd_sindir, file, "$$$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::Dirfile::include_affix", XS_GetData_include_affix, file, "$$$;$$$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::include_affix", XS_GetData_include_affix, file, "$$$;$$$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("GetData::Dirfile::fragment_namespace", XS_GetData_fragment_namespace, file, "$$;$");
        XSANY.any_i32 = 1;
        cv = newXSproto_portable("GetData::fragment_namespace", XS_GetData_fragment_namespace, file, "$$;$");
        XSANY.any_i32 = 0;
    }

    /* Initialisation Section */

#line 1182 "GetData.xs"
  gd_alloc_funcs(gdp_malloc, safefree);
  gdp_invalid = gd_invalid_dirfile();

#line 10496 "GetData.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

