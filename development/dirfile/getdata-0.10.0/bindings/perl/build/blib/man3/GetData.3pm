.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GetData 3"
.TH GetData 3 "2020-05-14" "perl v5.18.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GetData \- Perl bindings to the GetData library for Dirfile access
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use GetData;
\&
\&  my $DIRFILE = GetData::open("./dirfile/", $GetData::RDONLY);
\&
\&  # the following calls are equivalent
\&  my $data = GetData::getdata($DIRFILE, "field", 5, 0, 1,
\&                              $GetData::UINT8);
\&  my $data = $DIRFILE\->getdata("field", 5, 0, 1, $GetData::UINT8);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides simple, lightweight bindings from Perl to the C GetData
library.  It provides a simple mapping between public C functions and Perl
methods.  All C functions and constants are replicated in the GetData package.
These methods have the same name as their C counterparts, excluding the C
namespace prefix `gd_' (or `\s-1GD_\s0', for C preprocessor constants).
.PP
The dirfile lvalue returned by GetData::open is a simplistic object.  Any
GetData method which takes a dirfile as a parameter, may instead be called as
method of the dirfile object itself.  (See the synopsis above for an example.)
Dirfile metadata entries (which are C structs of type gd_entry_t) are
represented as simple hashes.
.PP
By default, GetData does not export any symbols.  All symbols in the GetData
package may be exported with:
.PP
.Vb 1
\&  use GetData "all";
.Ve
.PP
but this is discouraged, as it will overwrite useful things like &CORE::open.
.PP
Throughout the module, complex data are generally represented as
\&\f(CW\*(C`Math::Complex\*(C'\fR objects, but may be simplified to ordinary floating point
numbers if the imaginary part is zero.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
The module defines a large number of symbolic constants used by the \s-1API\s0 which
mirror the constants defined in the C \s-1API. \s0 The \*(L"constants\*(R" tag may be used to
export just the constants from the module, if desired.  Some genericly useful
sets of constants are discussed below.  Other constants are discussed in the
method descriptions where they are used.
.SS "Data Types"
.IX Subsection "Data Types"
GetData knows the following data types:
.ie n .IP "$GetData::NULL" 4
.el .IP "\f(CW$GetData::NULL\fR" 4
.IX Item "$GetData::NULL"
the null data type, which returns no data.
.ie n .IP "$GetData::UINT8" 4
.el .IP "\f(CW$GetData::UINT8\fR" 4
.IX Item "$GetData::UINT8"
unsigned 8\-bit integer
.ie n .IP "$GetData::INT8" 4
.el .IP "\f(CW$GetData::INT8\fR" 4
.IX Item "$GetData::INT8"
signed (two's complement) 8\-bit integer
.ie n .IP "$GetData::UINT16" 4
.el .IP "\f(CW$GetData::UINT16\fR" 4
.IX Item "$GetData::UINT16"
unsigned 16\-bit integer
.ie n .IP "$GetData::INT16" 4
.el .IP "\f(CW$GetData::INT16\fR" 4
.IX Item "$GetData::INT16"
signed (two's complement) 16\-bit integer
.ie n .IP "$GetData::UINT32" 4
.el .IP "\f(CW$GetData::UINT32\fR" 4
.IX Item "$GetData::UINT32"
unsigned 32\-bit integer
.ie n .IP "$GetData::INT32" 4
.el .IP "\f(CW$GetData::INT32\fR" 4
.IX Item "$GetData::INT32"
signed (two's complement) 32\-bit integer
.ie n .IP "$GetData::UINT64" 4
.el .IP "\f(CW$GetData::UINT64\fR" 4
.IX Item "$GetData::UINT64"
unsigned 64\-bit integer
.ie n .IP "$GetData::INT64" 4
.el .IP "\f(CW$GetData::INT64\fR" 4
.IX Item "$GetData::INT64"
signed (two's complement) 64\-bit integer
.ie n .IP "$GetData::FLOAT32" 4
.el .IP "\f(CW$GetData::FLOAT32\fR" 4
.IX Item "$GetData::FLOAT32"
\&\s-1IEEE\-754\s0 standard 32\-bit single precision floating point number
.ie n .IP "$GetData::FLOAT64" 4
.el .IP "\f(CW$GetData::FLOAT64\fR" 4
.IX Item "$GetData::FLOAT64"
\&\s-1IEEE\-754\s0 standard 64\-bit double precision floating point number
.ie n .IP "$GetData::COMPLEX64" 4
.el .IP "\f(CW$GetData::COMPLEX64\fR" 4
.IX Item "$GetData::COMPLEX64"
\&\s-1FORTRAN\s0 and C99 conformant 64\-bit single precision floating point complex number
.ie n .IP "$GetData::COMPLEX128" 4
.el .IP "\f(CW$GetData::COMPLEX128\fR" 4
.IX Item "$GetData::COMPLEX128"
\&\s-1FORTRAN\s0 and C99 conformant 128\-bit double precision floating point complex
number
.SS "Encoding Types"
.IX Subsection "Encoding Types"
The following encoding types are known by GetData:
.Sp
.RS 4
\&\f(CW$GetData::BZIP2_ENCODED\fR,
\&\f(CW$GetData::FLAC_ENCODED\fR,
\&\f(CW$GetData::GZIP_ENCODED\fR,
\&\f(CW$GetData::LZMA_ENCODED\fR,
\&\f(CW$GetData::SIE_ENCODED\fR,
\&\f(CW$GetData::SLIM_ENCODED\fR,
\&\f(CW$GetData::TEXT_ENCODED\fR,
\&\f(CW$GetData::ZZIP_ENCODED\fR,
\&\f(CW$GetData::ZZSLIM_ENCODED\fR,
\&\f(CW$GetData::UNENCODED\fR.
.RE
.PP
Details of these encoding types are given in the \fIdirfile\-format\fR\|(5) manual page.
.SS "Entry Types"
.IX Subsection "Entry Types"
The following symbols are used to indicate entry types:
.Sp
.RS 4
\&\f(CW$GetData::NO_ENTRY\fR,
\&\f(CW$GetData::BIT_ENTRY\fR,
\&\f(CW$GetData::CARRAY_ENTRY\fR,
\&\f(CW$GetData::CONST_ENTRY\fR,
\&\f(CW$GetData::DIVIDE_ENTRY\fR,
\&\f(CW$GetData::INDEX_ENTRY\fR,
\&\f(CW$GetData::LINCOM_ENTRY\fR,
\&\f(CW$GetData::LINTERP_ENTRY\fR,
\&\f(CW$GetData::MPLEX_ENTRY\fR,
\&\f(CW$GetData::MULTIPLY_ENTRY\fR,
\&\f(CW$GetData::PHASE_ENTRY\fR,
\&\f(CW$GetData::POLYNOM_ENTRY\fR,
\&\f(CW$GetData::RAW_ENTRY\fR,
\&\f(CW$GetData::RECIP_ENTRY\fR,
\&\f(CW$GetData::SBIT_ENTRY\fR,
\&\f(CW$GetData::STRING_ENTRY\fR,
\&\f(CW$GetData::WINDOW_ENTRY\fR
.RE
.PP
Of these, \f(CW$GetData::NO_ENTRY\fR is used to flag invalid entry types and
\&\f(CW$GetData::INDEX_ENTRY\fR is used only for the implicit \fB\s-1INDEX\s0\fR field.  See
\&\fIgd_entry\fR\|(3) and \fIdirfile\-format\fR\|(5) for details of the other entry types.
.SS "\s-1WINDOW\s0 Operators"
.IX Subsection "WINDOW Operators"
The following symbols are used to indicate \s-1WINDOW\s0 operators:
.Sp
.RS 4
\&\f(CW$GetData::WINDOP_EQ\fR,
\&\f(CW$GetData::WINDOP_GE\fR,
\&\f(CW$GetData::WINDOP_GT\fR,
\&\f(CW$GetData::WINDOP_LE\fR,
\&\f(CW$GetData::WINDOP_LT\fR,
\&\f(CW$GetData::WINDOP_NE\fR,
\&\f(CW$GetData::WINDOP_CLR\fR,
\&\f(CW$GetData::WINDOP_SET\fR.
.RE
.SH "INPUT DATA"
.IX Header "INPUT DATA"
Functions which take sets of data as input (add_carray, madd_carray,
put_carray, put_carray_slice, and putdata) accept data in a number of
ways.  The arguments specifying the data always appear at the end of the
argument list.  They are represented as \f(CW\*(C`{DATA...}\*(C'\fR in the method descriptions
below.  Input data arguments are parsed as follows.
.IP "1." 4
If the first data argument is undef, then it is ignored and all subsequent
arguments are taken as data:
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      undef, @data)
.Ve
.Sp
or
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      undef, $data[0], $data[1], $data[2], ...)
.Ve
.IP "2." 4
Otherwise, if the first data argument is a reference to an array, the array is
taken as data (and any further arguments are ignored):
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      \e@data)
.Ve
.IP "3." 4
Otherwise, if only two arguments make up the data argument list, and the second
is a reference to an array, the first is taken as a type code specifing the
conversion type, and the second is taken as the data:
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      $GetData::UINT8, \e@data)
.Ve
.IP "4." 4
Otherwise, if only two arguments make up the data argument list, and the second
is not a reference to an array, the first is, again, taken as a type code, and
the second is assumed to be a packed string containing the data in a format
appropriate for the type code specified:
.Sp
.Vb 3
\&    $packed_data = pack("C", @data)
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      $GetData::UINT8, $packed_data)
.Ve
.IP "5." 4
Otherwise, finally, the data argument list elements are simply taken as data
themselves:
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      @data)
.Ve
.Sp
or
.Sp
.Vb 2
\&    $dirfile\->putdata("field_code", $first_frame, $first_sample,
\&                      $data[0], $data[1], $data[2], ...)
.Ve
.PP
GetData internally converts the Perl data into a format readable by the C \s-1API.\s0
In cases 3 and 4 above, the type the data is converted into is specified
explicitly in the call.  In the other cases, GetData must guess an appropriate
C type into which to convert the data.  It does so by looking at the first
data value:
.IP "\(bu" 4
if the value is a \f(CW\*(C`Math::Complex\*(C'\fR object, the data are converted to double
precision complex data (\f(CW\*(C`COMPLEX128\*(C'\fR)
.IP "\(bu" 4
if the value is an integer, the data are converted to a 64\-bit signed integer
(\f(CW\*(C`INT64\*(C'\fR)
.IP "\(bu" 4
otherwise, the data are converted to a double precision float (\f(CW\*(C`FLOAT64\*(C'\fR).
.PP
Of the above methods, the first is only necessary when the data array has only
two elements, and so would be mistaken for method four if specified without the
initial undef.  Furthermore, the fourth method is typically the most efficient,
since the packed data scalar can often be used as the input to the C \s-1API\s0 without
need for type conversion.
.SH "ENTRY HASHES"
.IX Header "ENTRY HASHES"
The replacement for the \f(CW\*(C`gd_entry_t\*(C'\fR object of the C \s-1API\s0 is a simple hash.  The
key names are the same as the names of the \f(CW\*(C`gd_entry_t\*(C'\fR members.  (See
\&\fIgd_entry\fR\|(3) for details).
.PP
In entry hashes returned by GetData, only those keys appropriate for the entry
type specified will be present.  Entry hashes passed to GetData from the caller
may have other keys than those required by the entry type.  They will be
ignored.
.PP
The value associated with the \f(CW\*(C`field_type\*(C'\fR key will be one of the symbols
listed under \*(L"Entry Types\*(R" above.  For entry types which have (potentially)
more than one input field (\s-1DIVIDE, LINCOM, MPLEX, MULTIPLY, WINDOW\s0), the value
associated with the \f(CW"in_fields"\fR key will be a list of strings, regardless of
how many elements it has; other entry types which provide \f(CW"in_fields"\fR will be
a scalar, even though the key name is still plural.
.PP
Elements of the \f(CW\*(C`scalar\*(C'\fR array which are undef indicate literal parameters
(equivalent to \f(CW\*(C`NULL\*(C'\fR in the \f(CW\*(C`gd_entry_t\*(C'\fR's \f(CW\*(C`scalar\*(C'\fR member).  Similarly,
undef is used in \f(CW\*(C`scalar_ind\*(C'\fR where the C \s-1API\s0 uses \-1, to indicate \s-1CONST\s0
fields, instead of CARRAYs.
.SH "NON-MEMBER FUNCTIONS"
.IX Header "NON-MEMBER FUNCTIONS"
.IP "encoding_support ($ENCODING)" 4
.IX Item "encoding_support ($ENCODING)"
Returns \f(CW$GetData::RDWR\fR if the library can both read and write the specified
encoding, \f(CW$GetData::RDONLY\fR if it can only read, or \-1 otherwise.
\&\f(CW$ENCODING\fR should be one of the encoding symbols listed above in the
\&\*(L"Encoding Types\*(R" section.
.SH "DIRFILE CREATION METHODS"
.IX Header "DIRFILE CREATION METHODS"
.ie n .IP "open ($DIRFILENAME, $FLAGS, $SEHANDLER=undef, $EXTRA=undef)" 4
.el .IP "open ($DIRFILENAME, \f(CW$FLAGS\fR, \f(CW$SEHANDLER\fR=undef, \f(CW$EXTRA\fR=undef)" 4
.IX Item "open ($DIRFILENAME, $FLAGS, $SEHANDLER=undef, $EXTRA=undef)"
Create or open a Dirfile database called \f(CW$DIRFILENAME\fR.  \f(CW$FLAGS\fR should be
either \f(CW$GetData::RDONLY\fR (for read-only access) or \f(CW$GetData::RDWR\fR (for
read-write access), optionally bitwise or'd with any of the following flags:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::ARM_ENDIAN\fR,
\&\f(CW$GetData::BIG_ENDIAN\fR,
\&\f(CW$GetData::CREAT\fR,
\&\f(CW$GetData::EXCL\fR,
\&\f(CW$GetData::FORCE_ENCODING\fR,
\&\f(CW$GetData::FORCE_ENDIAN\fR,
\&\f(CW$GetData::IGNORE_DUPS\fR,
\&\f(CW$GetData::IGNORE_REFS\fR,
\&\f(CW$GetData::LITTLE_ENDIAN\fR,
\&\f(CW$GetData::NOT_ARM_ENDIAN\fR,
\&\f(CW$GetData::PEDANTIC\fR,
\&\f(CW$GetData::PERMISSIVE\fR,
\&\f(CW$GetData::PRETTY_PRINT\fR,
\&\f(CW$GetData::TRUNC\fR,
\&\f(CW$GetData::TRUNCSUB\fR,
\&\f(CW$GetData::VERBOSE\fR,
.RE
.RE
.RS 4
.Sp
and at most one of the encoding symbols listed above in the \*(L"Encoding Types\*(R"
section or else \f(CW$GetData::AUTO_ENCODED\fR indicating that GetData should attempt
to automatically determine the encoding.  The meaning of the dirfile flags
may be found in the \fIgd_cbopen\fR\|(3) manual page.
.Sp
\&\f(CW$SEHANDLER\fR is a Perl callback function which will be executed whenever a syntax
error is encountered.  It may be undef, if no callback is desired.  When
called, \f(CW$SEHANDLER\fR will be passed two arguments.  The first is a reference to
a hash containing the parser data.  The second is the \f(CW$EXTRA\fR scalar passed to
this method.  \f(CW$SEHANDLER\fR is called in scalar context, and should return
either:
.IP "\(bu" 4
an integer, one of the symbolic constants:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::SYNTAX_ABORT\fR,
\&\f(CW$GetData::SYNTAX_CONTINUE\fR,
\&\f(CW$GetData::SYNTAX_IGNORE\fR,
\&\f(CW$GetData::SYNTAX_RESCAN\fR;
.RE
.RE
.RS 4
.Sp
(see \fIgd_cbopen\fR\|(3) for their meaning), or
.RE
.IP "\(bu" 4
a string containing the corrected line, in which case \f(CW$GetData::SYNTAX_RESCAN\fR
is assumed; or,
.IP "\(bu" 4
a reference to a list consisting of an integer, one of the
\&\f(CW\*(C`$GetData::SYNTAX_...\*(C'\fR constants listed above, and then, optionally, a string
containing the corrected line.
.RE
.RS 4
.Sp
This function always returns a Dirfile object, even if the call failed;
the caller should use the returned dirfile's error() method to test for
success.  On error, the returned object will be flagged as invalid.
.RE
.IP "invalid_dirfile ()" 4
.IX Item "invalid_dirfile ()"
This function always returns a newly created, but invalid, Dirfile object.
Unlike an invalid dirfile created (either accidentally or purposefully) using
open(), the dirfile returned by this function always has a zero error code.
See \fIgd_invalid_dirfile\fR\|(3).
.SH "DIRFILE OBJECT METHODS"
.IX Header "DIRFILE OBJECT METHODS"
The following methods all operate on a dirfile object returned by one of the
above methods and can either be called as:
.PP
.Vb 1
\&  $GetData::method($dirfile, ...)
.Ve
.PP
or else, as
.PP
.Vb 1
\&  $dirfile\->method(...)
.Ve
.PP
without change in operation.
.SS "List of Methods"
.IX Subsection "List of Methods"
.ie n .IP "$dirfile\->add_carray ($FIELD_NAME, $DATA_TYPE, $FRAGMENT_INDEX, {\s-1DATA...\s0})" 4
.el .IP "\f(CW$dirfile\fR\->add_carray ($FIELD_NAME, \f(CW$DATA_TYPE\fR, \f(CW$FRAGMENT_INDEX\fR, {\s-1DATA...\s0})" 4
.IX Item "$dirfile->add_carray ($FIELD_NAME, $DATA_TYPE, $FRAGMENT_INDEX, {DATA...})"
Adds a new \s-1CARRAY\s0 field called \f(CW$FIELD_NAME\fR to the metadata fragment indexed
by \f(CW$FRAGMENT_INDEX\fR.  The storage type of the \s-1CARRAY\s0 is given by
\&\f(CW$DATA_TYPE\fR, which should be one of the symbols listed above under
\&\*(L"Data Types\*(R".  The value of the \s-1CARRAY\s0 is then set to the data given in
the \f(CW\*(C`{DATA...}\*(C'\fR argument list, which also determines its length.  See the
\&\*(L"Input Data\*(R" section above for details on the allowed forms of \f(CW\*(C`{DATA...}\*(C'\fR.
See \fIgd_add_carray\fR\|(3).
.ie n .IP "$dirfile\->add_const ($FIELD_NAME, $DATA_TYPE, [$VALUE, $FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_const ($FIELD_NAME, \f(CW$DATA_TYPE\fR, [$VALUE, \f(CW$FRAGMENT_INDEX\fR])" 4
.IX Item "$dirfile->add_const ($FIELD_NAME, $DATA_TYPE, [$VALUE, $FRAGMENT_INDEX])"
Adds a new \s-1CONST\s0 field called \f(CW$FIELD_NAME\fR to the metadata fragment indexed
by \f(CW$FRAGMENT_INDEX\fR, or to the primary format file if omitted.  The
\&\f(CW$DATA_TYPE\fR argument indicates the storage type, which should be one of the
symbols listed above under \*(L"Data Types\*(R".  If given, the value of the field
is set to \f(CW$VALUE\fR, otherwise the field will be initialised to zero.  See
\&\fIgd_add_const\fR\|(3).
.ie n .IP "$dirfile\->aliases ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->aliases ($FIELD_CODE)" 4
.IX Item "$dirfile->aliases ($FIELD_CODE)"
In scalar context, returns the number of aliases of \f(CW$FIELD_CODE\fR.  In list
context, returns an array of alias names for \f(CW$FIELD_CODE\fR.  See \fIgd_naliases\fR\|(3)
and \fIgd_aliases\fR\|(3).
.ie n .IP "$dirfile\->carrays ($RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->carrays ($RETURN_TYPE)" 4
.IX Item "$dirfile->carrays ($RETURN_TYPE)"
Returns the value of all carrays (excluding metafields) in the dirfile after
converting them to the return type \f(CW$RETURN_TYPE\fR, which should be one of the
symbols listed under \*(L"Data Types\*(R" above.  If called in scalar context,
returns a reference to an array of packed string data.  If called in list
context, returns an array of arrays of unpacked data.  See \fIgd_carrays\fR\|(3).
.ie n .IP "$dirfile\->close ()" 4
.el .IP "\f(CW$dirfile\fR\->close ()" 4
.IX Item "$dirfile->close ()"
Closes the dirfile, writing changes to disk.  Upon successful completion, the
dirfile object will be invalidated, prohibiting further operation on it.  A
dirfile which is destroyed by garbage collection is discarded (see \*(L"discard\*(R"
below).  This function should be called if metadata need to be written to disk
before the object goes out of scope.  See \fIgd_close\fR\|(3).
.ie n .IP "$dirfile\->constants ($RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->constants ($RETURN_TYPE)" 4
.IX Item "$dirfile->constants ($RETURN_TYPE)"
Returns the value of all constants (excluding metafields) in the dirfile after
converting them to the return type \f(CW$RETURN_TYPE\fR, which should be one of the
symbols listed under \*(L"Data Types\*(R" above.  If called in scalar context,
returns a packed string containing the data.  If called in list context, the
data will be unpacked and returned as an array.  See \fIgd_constants\fR\|(3).
.ie n .IP "$dirfile\->discard ()" 4
.el .IP "\f(CW$dirfile\fR\->discard ()" 4
.IX Item "$dirfile->discard ()"
Closes the dirfile, ignoring changes to metadata, but writing changed data to
disk.  Upon successful completion, the dirfile object will be invalidated,
prohibiting further operation on it.  This function is called automatically by
the dirfile destructor, and need not be called explicitly.  To save the metadata
on close, use \*(L"close\*(R".  See \fIgd_discard\fR\|(3).
.ie n .IP "$dirfile\->entry ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->entry ($FIELD_CODE)" 4
.IX Item "$dirfile->entry ($FIELD_CODE)"
If called in scalar context, returns the entry type of \f(CW$FIELD_CODE\fR, one
of the symbols listed above under \*(L"Entry Types\*(R".  In array context, returns
a hash describing the indicated field.  See \fIgd_entry_type\fR\|(3) and \fIgd_entry\fR\|(3).
.ie n .IP "$dirfile\->match_entries ($REGEX, $FRAGMENT, $TYPE, $FLAGS)" 4
.el .IP "\f(CW$dirfile\fR\->match_entries ($REGEX, \f(CW$FRAGMENT\fR, \f(CW$TYPE\fR, \f(CW$FLAGS\fR)" 4
.IX Item "$dirfile->match_entries ($REGEX, $FRAGMENT, $TYPE, $FLAGS)"
In scalar context, returns the number of entries matching the supplied criteria.
In list context, returns an array of the names of the entries.  If \f(CW$REGEX\fR is
not undef, it is a regular expression which is matched against entry names.
.Sp
\&\fB\s-1NB:\s0\fR The regular expression handling is done in the underlying C library,
not in Perl.  As a result, using Perl's regex grammar in \f(CW$REGEX\fR usually won't
work as desired.  If the C GetData library has Perl-Compatible Regular
Expression (\s-1PCRE\s0) support, the \f(CW$GetData::REGEX_PCRE\fR flag can be used to
select a regular expression grammar which is very similar to Perl's own.
.Sp
If \f(CW$FRAGMENT\fR is not \f(CW$GetData::ALL_FRAGMENTS\fR or undef, only entries defined in
the specified fragment are searched.  If \f(CW$TYPE\fR is one of the entry types
listed above under \*(L"Entry Types\*(R", only entries of that type are considered.
Alternatley, \f(CW$TYPE\fR may be one of:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::ALL_ENTRIES\fR,
\&\f(CW$GetData::SCALAR_ENTRIES\fR,
\&\f(CW$GetData::VECTOR_ENTRIES\fR.
.RE
.RE
.RS 4
.Sp
Setting \f(CW$TYPE\fR to undef is equivalent to setting it to
\&\f(CW$GetData::ALL_ENTRIES\fR.  If not undef, which is treated as zero, \f(CW$FLAGS\fR
should be zero or more of the following flags:
.Sp
.RS 4
\&\f(CW$GetData::ENTRIES_HIDDEN\fR,
\&\f(CW$GetData::ENTRIES_NOALIAS\fR,
\&\f(CW$GetData::REGEX_PCRE\fR,
\&\f(CW$GetData::REGEX_EXTENDED\fR,
\&\f(CW$GetData::REGEX_ICASE\fR,
\&\f(CW$GetData::REGEX_CASELESS\fR,
\&\f(CW$GetData::REGEX_JAVASCRIPT\fR,
\&\f(CW$GetData::REGEX_UNICODE\fR
.RE
.RE
.RS 4
.Sp
See \fIgd_match_entries\fR\|(3) for the meaning of these symbols.
.RE
.ie n .IP "$dirfile\->entry_list ($PARENT, $TYPE, $FLAGS)" 4
.el .IP "\f(CW$dirfile\fR\->entry_list ($PARENT, \f(CW$TYPE\fR, \f(CW$FLAGS\fR)" 4
.IX Item "$dirfile->entry_list ($PARENT, $TYPE, $FLAGS)"
In scalar context, returns the number of entries matching the supplied criteria.
In list context, returns an array of the names of the entries.  If \f(CW$PARENT\fR
is undef, top-level entries are considered, otherwise meta entries under
\&\f(CW$PARENT\fR are considered.  For \f(CW$TYPE\fR and \f(CW$FLAGS\fR, see
\&\f(CW\*(C`$dirfile\-\*(C'\fRmatch_entries> above (the regex flags listed there are ignored by
this function), and also \fIgd_nentries\fR\|(3) and \fIgd_entry_list\fR\|(3).
.ie n .IP "$dirfile\->error ()" 4
.el .IP "\f(CW$dirfile\fR\->error ()" 4
.IX Item "$dirfile->error ()"
Returns the error code of the last operation on this dirfile.  See \fIgd_error\fR\|(3).
.ie n .IP "$dirfile\->error_string ()" 4
.el .IP "\f(CW$dirfile\fR\->error_string ()" 4
.IX Item "$dirfile->error_string ()"
Returns a string describing the error encountered (if any) by the last operation
on this dirfile.  See \fIgd_error_string\fR\|(3).
.ie n .IP "$dirfile\->field_list ()" 4
.el .IP "\f(CW$dirfile\fR\->field_list ()" 4
.IX Item "$dirfile->field_list ()"
Equivalent to: \f(CW\*(C`$dirfile\->entry_list(undef, undef, undef)\*(C'\fR.
.ie n .IP "$dirfile\->field_list_by_type ($TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->field_list_by_type ($TYPE)" 4
.IX Item "$dirfile->field_list_by_type ($TYPE)"
Equivalent to: \f(CW\*(C`$dirfile\->entry_list(undef, $TYPE, undef)\*(C'\fR.
.ie n .IP "$dirfile\->fragment_affixes ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->fragment_affixes ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->fragment_affixes ($FRAGMENT_INDEX)"
Returns an array containing the prefix (first) and suffix (second) of the
fragment indexed by \f(CW$FRAGMENT_INDEX\fR.  See \fIgd_fragment_affixes\fR\|(3).
.ie n .IP "$dirfile\->fragments ()" 4
.el .IP "\f(CW$dirfile\fR\->fragments ()" 4
.IX Item "$dirfile->fragments ()"
In scalar context, returns the number of metadata fragments in the dirfile.
In list context, returns an array of pathnames to the fragments on disk, in the
order that they're indexed.  See \fIgd_nfragments\fR\|(3) and \fIgd_fragmentname\fR\|(3).
.ie n .IP "$dirfile\->get_carray ($FIELD_CODE, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->get_carray ($FIELD_CODE, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->get_carray ($FIELD_CODE, $RETURN_TYPE)"
Returns the value of the \s-1CARRAY\s0 named \f(CW$FIELD_CODE\fR after converting its
elements to the return type \f(CW$RETURN_TYPE\fR, which should be one of the symbols
listed under \*(L"Data Types\*(R" above.  If \f(CW$RETURN_TYPE\fR is \f(CW$GetData::NULL\fR,
in scalar context this function returns undef.  Otherwise, if called in scalar
context, returns a packed string containing the data.  If called in list
context, the data will be unpacked and returned as an array.  See
\&\fIgd_get_carray\fR\|(3).
.ie n .IP "$dirfile\->get_carray_slice ($FIELD_CODE, $START, $LEN, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->get_carray_slice ($FIELD_CODE, \f(CW$START\fR, \f(CW$LEN\fR, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->get_carray_slice ($FIELD_CODE, $START, $LEN, $RETURN_TYPE)"
Returns the value of a portion of the \s-1CARRAY\s0 named \f(CW$FIELD_CODE\fR after
converting its elements to the return type \f(CW$RETURN_TYPE\fR, which should be one
of the symbols listed under \*(L"Data Types\*(R" above.  The first element returned
is given by \f(CW$START\fR, and the number of elements by \f(CW$LEN\fR.  If
\&\f(CW$RETURN_TYPE\fR is \f(CW$GetData::NULL\fR, in scalar context this function returns
undef.  Otherwise, if called in scalar context, returns a packed string
containing the data.  If called in list context, the data will be unpacked and
returned as an array.  Less data than requested may be returned, if insufficient
data exist.  See \fIgd_get_carray_slice\fR\|(3).
.ie n .IP "$dirfile\->get_constant ($FIELD_CODE, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->get_constant ($FIELD_CODE, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->get_constant ($FIELD_CODE, $RETURN_TYPE)"
Returns the value of the \s-1CONST\s0 named \f(CW$FIELD_CODE\fR after converting it to the
return type \f(CW$RETURN_TYPE\fR, which should be one of the symbols listed under
\&\*(L"Data Types\*(R" above.  If \f(CW$RETURN_TYPE\fR is \f(CW$GetData::NULL\fR, returns undef
on success.  See \fIgd_get_constant\fR\|(3).
.ie n .IP "$dirfile\->getdata ($FIELD_CODE, $FIRST_FRAME, $FIRST_SAMP, $NUM_FRAMES, $NUM_SAMP, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->getdata ($FIELD_CODE, \f(CW$FIRST_FRAME\fR, \f(CW$FIRST_SAMP\fR, \f(CW$NUM_FRAMES\fR, \f(CW$NUM_SAMP\fR, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->getdata ($FIELD_CODE, $FIRST_FRAME, $FIRST_SAMP, $NUM_FRAMES, $NUM_SAMP, $RETURN_TYPE)"
Returns data from the field specified by \f(CW$FIELD_CODE\fR after converting them
to the return type \f(CW$RETURN_TYPE\fR, which should be one of the symbols listed
under \*(L"Data Types\*(R" above.  The first sample returned is \f(CW$FIRST_SAMP\fR
samples after the start of \f(CW$FIRST_FRAME\fR and the amount of data returned is
\&\f(CW$NUM_FRAMES\fR frames plus \f(CW$NUM_SAMP\fR samples.  If \f(CW$RETURN_TYPE\fR is
\&\f(CW$GetData::NULL\fR, in scalar context this function returns the number of
samples read.  Otherwise, if called in scalar context, it returns a string of
packed data.  If called in array context, the data will be unpacked and returned
as an array.  Complex data are returned as \f(CW\*(C`Math::Complex\*(C'\fR objects.  See
\&\fIgd_getdata\fR\|(3).
.ie n .IP "$dirfile\->get_string ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->get_string ($FIELD_CODE)" 4
.IX Item "$dirfile->get_string ($FIELD_CODE)"
Returns the value of the \s-1STRING\s0 named \f(CW$FIELD_CODE\fR.  See \fIgd_get_string\fR\|(3).
.ie n .IP "$dirfile\->include ($FILE, $PARENT_FRAGMENT, $FLAGS, [$PREFIX, $SUFFIX])" 4
.el .IP "\f(CW$dirfile\fR\->include ($FILE, \f(CW$PARENT_FRAGMENT\fR, \f(CW$FLAGS\fR, [$PREFIX, \f(CW$SUFFIX\fR])" 4
.IX Item "$dirfile->include ($FILE, $PARENT_FRAGMENT, $FLAGS, [$PREFIX, $SUFFIX])"
Includes the fragment metadata file \f(CW$FILE\fR under the fragment indexed by
\&\f(CW$PARENT_FRAGMENT\fR.  \f(CW$FLAGS\fR should be a bitwise or'd collection of zero or
more of the following flags:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::BIG_ENDIAN\fR,
\&\f(CW$GetData::CREAT\fR,
\&\f(CW$GetData::EXCL\fR,
\&\f(CW$GetData::FORCE_ENCODING\fR,
\&\f(CW$GetData::FORCE_ENDIAN\fR,
\&\f(CW$GetData::IGNORE_DUPS\fR,
\&\f(CW$GetData::IGNORE_REFS\fR,
\&\f(CW$GetData::LITTLE_ENDIAN\fR,
\&\f(CW$GetData::PEDANTIC\fR,
\&\f(CW$GetData::TRUNC\fR,
.RE
.RE
.RS 4
.Sp
and at most one of the encoding symbols listed above in the \*(L"Encoding Types\*(R"
section or else \f(CW$GetData::AUTO_ENCODED\fR indicating that GetData should attempt
to automatically determine the encoding.  If \f(CW$PREFIX\fR or \f(CW$SUFFIX\fR are
omitted or undef, the added fragment will contain no such affix.  See
\&\fIgd_include_affix\fR\|(3).
.RE
.ie n .IP "$dirfile\->madd_carray ($PARENT, $FIELD_NAME, $DATA_TYPE, {\s-1DATA...\s0})" 4
.el .IP "\f(CW$dirfile\fR\->madd_carray ($PARENT, \f(CW$FIELD_NAME\fR, \f(CW$DATA_TYPE\fR, {\s-1DATA...\s0})" 4
.IX Item "$dirfile->madd_carray ($PARENT, $FIELD_NAME, $DATA_TYPE, {DATA...})"
Adds a new \s-1CARRAY\s0 metafield called \f(CW$FIELD_NAME\fR under the parent field
\&\f(CW$PARENT\fR.  The storage type of the \s-1CARRAY\s0 is given by \f(CW$DATA_TYPE\fR, which
should be one of the symbols listed above under \*(L"Data Types\*(R".  The value of
the \s-1CARRAY\s0 is then set to the data given in the \f(CW\*(C`{DATA...}\*(C'\fR argument list,
which also determines its length.  See the \*(L"Input Data\*(R" section above for
details on the allowed forms of \f(CW\*(C`{DATA...}\*(C'\fR.  See \fIgd_madd_carray\fR\|(3).
.ie n .IP "$dirfile\->madd_const ($PARENT, $FIELD_NAME, $DATA_TYPE, [$VALUE])" 4
.el .IP "\f(CW$dirfile\fR\->madd_const ($PARENT, \f(CW$FIELD_NAME\fR, \f(CW$DATA_TYPE\fR, [$VALUE])" 4
.IX Item "$dirfile->madd_const ($PARENT, $FIELD_NAME, $DATA_TYPE, [$VALUE])"
Adds a new \s-1CONST\s0 metafield called \f(CW$FIELD_NAME\fR under the field \f(CW$PARENT\fR.
The \f(CW$DATA_TYPE\fR argument indicates the storage type, which should be one of
the symbols listed above under \*(L"Data Types\*(R".  If given, the value of the
field is set to \f(CW$VALUE\fR, otherwise the field will be initialised to zero.
See \fIgd_madd_const\fR\|(3).
.ie n .IP "$dirfile\->mcarrays ($PARENT, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->mcarrays ($PARENT, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->mcarrays ($PARENT, $RETURN_TYPE)"
Behaves analogously to carrays() (\fIq.v.\fR), but returns CARRAYs which are
metafields under the parent specified by \f(CW$PARENT\fR.
.ie n .IP "$dirfile\->mconstants ($PARENT, $RETURN_TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->mconstants ($PARENT, \f(CW$RETURN_TYPE\fR)" 4
.IX Item "$dirfile->mconstants ($PARENT, $RETURN_TYPE)"
Behaves analogously to constants() (\fIq.v.\fR), but returns CONSTs which are
metafields under the parent specified by \f(CW$PARENT\fR.
.ie n .IP "$dirfile\->mfield_list ($PARENT)" 4
.el .IP "\f(CW$dirfile\fR\->mfield_list ($PARENT)" 4
.IX Item "$dirfile->mfield_list ($PARENT)"
Equivalent to \f(CW\*(C`$dirfile\->entry_list($PARENT, undef, undef)\*(C'\fR.
.ie n .IP "$dirfile\->mfield_list_by_type ($PARENT, $TYPE)" 4
.el .IP "\f(CW$dirfile\fR\->mfield_list_by_type ($PARENT, \f(CW$TYPE\fR)" 4
.IX Item "$dirfile->mfield_list_by_type ($PARENT, $TYPE)"
Equivalent to \f(CW\*(C`$dirfile\->entry_list($PARENT, $TYPE, undef)\*(C'\fR.
.ie n .IP "$dirfile\->mstrings ($PARENT)" 4
.el .IP "\f(CW$dirfile\fR\->mstrings ($PARENT)" 4
.IX Item "$dirfile->mstrings ($PARENT)"
Behaves analogously to strings() (\fIq.v.\fR), but returns STRINGs which are
metafields under the parent specified by \f(CW$PARENT\fR.
.ie n .IP "$dirfile\->mvector_list ($PARENT)" 4
.el .IP "\f(CW$dirfile\fR\->mvector_list ($PARENT)" 4
.IX Item "$dirfile->mvector_list ($PARENT)"
Equivalent to:
  \f(CW$dirfile\fR\->entry_list($PARENT, \f(CW$GetData::VECTOR_ENTRIES\fR, undef).
.ie n .IP "$dirfile\->parser_callback ($SEHANDLER, $EXTRA=undef)" 4
.el .IP "\f(CW$dirfile\fR\->parser_callback ($SEHANDLER, \f(CW$EXTRA\fR=undef)" 4
.IX Item "$dirfile->parser_callback ($SEHANDLER, $EXTRA=undef)"
Sets the registered parser callback function for the dirfile to \f(CW$SEHANDLER\fR,
or to nothing if undef, and updates the \f(CW$EXTRA\fR parameter.  See
\&\fIgd_parser_callback\fR\|(3).
.ie n .IP "$dirfile\->put_carray ($FIELD_CODE, {\s-1DATA...\s0})" 4
.el .IP "\f(CW$dirfile\fR\->put_carray ($FIELD_CODE, {\s-1DATA...\s0})" 4
.IX Item "$dirfile->put_carray ($FIELD_CODE, {DATA...})"
Sets the value of the \s-1CARRAY\s0 named \f(CW$FIELD_CODE\fR to the values contained in
the \f(CW\*(C`{DATA...}\*(C'\fR argument list.  See the \*(L"Input Data\*(R" section above for
details on the allowed forms of \f(CW\*(C`{DATA...}\*(C'\fR.  See \fIgd_put_carray\fR\|(3).
.ie n .IP "$dirfile\->put_carray_slice ($FIELD_CODE, $START, {\s-1DATA...\s0})" 4
.el .IP "\f(CW$dirfile\fR\->put_carray_slice ($FIELD_CODE, \f(CW$START\fR, {\s-1DATA...\s0})" 4
.IX Item "$dirfile->put_carray_slice ($FIELD_CODE, $START, {DATA...})"
Sets a value of the portion of the \s-1CARRAY\s0 named \f(CW$FIELD_CODE\fR beginning with
element numbered \f(CW$START\fR to the values contained in the \f(CW\*(C`{DATA...}\*(C'\fR argument
list.  See the \*(L"Input Data\*(R" section above for details on the allowed forms
of \f(CW\*(C`{DATA...}\*(C'\fR.  See \fIgd_put_carray_slice\fR\|(3).
.ie n .IP "$dirfile\->put_constant ($FIELD_CODE, $DATUM)" 4
.el .IP "\f(CW$dirfile\fR\->put_constant ($FIELD_CODE, \f(CW$DATUM\fR)" 4
.IX Item "$dirfile->put_constant ($FIELD_CODE, $DATUM)"
Sets the value of the \s-1CONST\s0 field \f(CW$FIELD_CODE\fR to the value \f(CW$DATUM\fR.  See
\&\fIgd_put_constant\fR\|(3).
.ie n .IP "$dirfile\->putdata ($FIELD_CODE, $FIRST_FRAME, $FIRST_SAMPLE, {\s-1DATA...\s0})" 4
.el .IP "\f(CW$dirfile\fR\->putdata ($FIELD_CODE, \f(CW$FIRST_FRAME\fR, \f(CW$FIRST_SAMPLE\fR, {\s-1DATA...\s0})" 4
.IX Item "$dirfile->putdata ($FIELD_CODE, $FIRST_FRAME, $FIRST_SAMPLE, {DATA...})"
Sets a portion of the vector given by \f(CW$FIELD_CODE\fR to the values contained in
the \f(CW\*(C`{DATA...}\*(C'\fR argument list.  The first sample written is \f(CW$FIRST_SAMPLE\fR
samples after the start of \f(CW$FIRST_FRAME\fR.  See the \*(L"Input Data\*(R" section
above for details on the allowed forms of \f(CW\*(C`{DATA...}\*(C'\fR.  See \fIgd_putdata\fR\|(3).
.ie n .IP "$dirfile\->strings ()" 4
.el .IP "\f(CW$dirfile\fR\->strings ()" 4
.IX Item "$dirfile->strings ()"
In scalar context, returns the number of \s-1STRING\s0 fields.  In list context,
returns an array of strings containing the values of all the \s-1STRING\s0 fields.
See \fIgd_strings\fR\|(3).
.ie n .IP "$dirfile\->strtok ($STRING)" 4
.el .IP "\f(CW$dirfile\fR\->strtok ($STRING)" 4
.IX Item "$dirfile->strtok ($STRING)"
Tokenises \f(CW$STRING\fR, returning an array of tokens.  See \fIgd_strtok\fR\|(3).
.ie n .IP "$dirfile\->vector_list ()" 4
.el .IP "\f(CW$dirfile\fR\->vector_list ()" 4
.IX Item "$dirfile->vector_list ()"
Equivalent to:
  \f(CW$dirfile\fR\->entry_list(undef, \f(CW$GetData::VECTOR_ENTRIES\fR, undef).
.SS "Other Methods"
.IX Subsection "Other Methods"
For the most part, following methods behave identically to their C \s-1API\s0
counterpart.  See the corresponding C \s-1API\s0 manual page for details.  Different
behaviour, if any, is indicated.
.ie n .IP "$dirfile\->add ($ENTRY)" 4
.el .IP "\f(CW$dirfile\fR\->add ($ENTRY)" 4
.IX Item "$dirfile->add ($ENTRY)"
\&\f(CW$ENTRY\fR should be a reference to an entry hash; see \*(L"\s-1ENTRY HASHES\*(R"\s0 above.
.ie n .IP "$dirfile\->add_alias ($FIELD_CODE, $TARGET, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_alias ($FIELD_CODE, \f(CW$TARGET\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_alias ($FIELD_CODE, $TARGET, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_bit ($FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_bit ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_bit ($FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_divide ($FIELD_CODE, $IN_FIELD1, $IN_FIELD2, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_divide ($FIELD_CODE, \f(CW$IN_FIELD1\fR, \f(CW$IN_FIELD2\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_divide ($FIELD_CODE, $IN_FIELD1, $IN_FIELD2, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_lincom ($FIELD_CODE, $N_FIELDS, $IN_FIELDS, $M, $B, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_lincom ($FIELD_CODE, \f(CW$N_FIELDS\fR, \f(CW$IN_FIELDS\fR, \f(CW$M\fR, \f(CW$B\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_lincom ($FIELD_CODE, $N_FIELDS, $IN_FIELDS, $M, $B, [$FRAGMENT_INDEX])"
\&\f(CW$IN_FIELDS\fR, \f(CW$M\fR, and \f(CW$B\fR should be references to arrays of the
appropriate length.  The elements of \f(CW$M\fR and \f(CW$B\fR may be of any numerical
type, including \f(CW\*(C`Math::Complex\*(C'\fR.  \f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not
specified.
.ie n .IP "$dirfile\->add_linterp ($FIELD_CODE, $IN_FIELD, $TABLE, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_linterp ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$TABLE\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_linterp ($FIELD_CODE, $IN_FIELD, $TABLE, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_mplex ($FIELD_CODE, $IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_mplex ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$COUNT_FIELD\fR, \f(CW$COUNT_VAL\fR, \f(CW$COUNT_MAX\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_mplex ($FIELD_CODE, $IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_multiply ($FIELD_CODE, $IN_FIELD1, $IN_FIELD2, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_multiply ($FIELD_CODE, \f(CW$IN_FIELD1\fR, \f(CW$IN_FIELD2\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_multiply ($FIELD_CODE, $IN_FIELD1, $IN_FIELD2, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_phase ($FIELD_CODE, $IN_FIELD, $SHIFT, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_phase ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$SHIFT\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_phase ($FIELD_CODE, $IN_FIELD, $SHIFT, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_polynom ($FIELD_CODE, $POLY_ORD, $IN_FIELD, $A, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_polynom ($FIELD_CODE, \f(CW$POLY_ORD\fR, \f(CW$IN_FIELD\fR, \f(CW$A\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_polynom ($FIELD_CODE, $POLY_ORD, $IN_FIELD, $A, [$FRAGMENT_INDEX])"
\&\f(CW$A\fR should be a reference to an array of numbers (of any numerical type,
including \f(CW\*(C`Math::Complex\*(C'\fR) of the appropriate length.  \f(CW$FRAGMENT_INDEX\fR = 0
is assumed if not specified.
.ie n .IP "$dirfile\->add_raw ($FIELD_CODE, $DATA_TYPE, $SPF, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_raw ($FIELD_CODE, \f(CW$DATA_TYPE\fR, \f(CW$SPF\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_raw ($FIELD_CODE, $DATA_TYPE, $SPF, [$FRAGMENT_INDEX])"
\&\f(CW$DATA_TYPE\fR should be one of the symbols listed under \*(L"Data Types\*(R" above.
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_recip ($FIELD_CODE, $IN_FIELD, $DIVIDEND, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_recip ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$DIVIDEND\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_recip ($FIELD_CODE, $IN_FIELD, $DIVIDEND, [$FRAGMENT_INDEX])"
\&\f(CW$DIVIDEND\fR may be of any numerical type, including \f(CW\*(C`Math::Complex\*(C'\fR.
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_sbit ($FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_sbit ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_sbit ($FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_spec ($LINE, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_spec ($LINE, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_spec ($LINE, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_string ($FIELD_CODE, $VALUE, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_string ($FIELD_CODE, \f(CW$VALUE\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_string ($FIELD_CODE, $VALUE, [$FRAGMENT_INDEX])"
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->add_window ($FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD, [$FRAGMENT_INDEX])" 4
.el .IP "\f(CW$dirfile\fR\->add_window ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$CHECK_FIELD\fR, \f(CW$WINDOP\fR, \f(CW$THRESHOLD\fR, [$FRAGMENT_INDEX])" 4
.IX Item "$dirfile->add_window ($FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD, [$FRAGMENT_INDEX])"
\&\f(CW$WINDOP\fR should be one of the symbols listed under \*(L"\s-1WINDOW\s0 Operators\*(R" above.
\&\f(CW$FRAGMENT_INDEX\fR = 0 is assumed if not specified.
.ie n .IP "$dirfile\->alias_target ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->alias_target ($FIELD_CODE)" 4
.IX Item "$dirfile->alias_target ($FIELD_CODE)"

.ie n .IP "$dirfile\->alter_affixes ($FRAGMENT_INDEX, $PREFIX, [$SUFFIX])" 4
.el .IP "\f(CW$dirfile\fR\->alter_affixes ($FRAGMENT_INDEX, \f(CW$PREFIX\fR, [$SUFFIX])" 4
.IX Item "$dirfile->alter_affixes ($FRAGMENT_INDEX, $PREFIX, [$SUFFIX])"
If \f(CW$PREFIX\fR or \f(CW$SUFFIX\fR are undef, or if \f(CW$SUFFIX\fR is omitted, that
affix is not changed.
.ie n .IP "$dirfile\->alter_bit ($FIELD_CODE, [$IN_FIELD, $BITNUM, $NUMBITS])" 4
.el .IP "\f(CW$dirfile\fR\->alter_bit ($FIELD_CODE, [$IN_FIELD, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR])" 4
.IX Item "$dirfile->alter_bit ($FIELD_CODE, [$IN_FIELD, $BITNUM, $NUMBITS])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW\*(C`$BITNUM == \-1\*(C'\fR, or \f(CW\*(C`$NUMBITS == 0\*(C'\fR, that parameter is not
changed.
.ie n .IP "$dirfile\->alter_carray ($FIELD_CODE, $CONST_TYPE, $ARRAY_LEN)" 4
.el .IP "\f(CW$dirfile\fR\->alter_carray ($FIELD_CODE, \f(CW$CONST_TYPE\fR, \f(CW$ARRAY_LEN\fR)" 4
.IX Item "$dirfile->alter_carray ($FIELD_CODE, $CONST_TYPE, $ARRAY_LEN)"
\&\f(CW$CONST_TYPE\fR should be one of the symbols listed under \*(L"Data Types\*(R" above.
.ie n .IP "$dirfile\->alter_const ($FIELD_CODE, [$CONST_TYPE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_const ($FIELD_CODE, [$CONST_TYPE])" 4
.IX Item "$dirfile->alter_const ($FIELD_CODE, [$CONST_TYPE])"
If \f(CW$CONST_TYPE\fR is omitted, or equal to \f(CW$GetData::NULL\fR, it is not changed;
otherwise, it should be one of the symbols listed under \*(L"Data Types\*(R" above.
.ie n .IP "$dirfile\->alter_divide ($FIELD_CODE, [$IN_FIELD1, $IN_FIELD2])" 4
.el .IP "\f(CW$dirfile\fR\->alter_divide ($FIELD_CODE, [$IN_FIELD1, \f(CW$IN_FIELD2\fR])" 4
.IX Item "$dirfile->alter_divide ($FIELD_CODE, [$IN_FIELD1, $IN_FIELD2])"
Arguments not given or set to undef are not changed.
.ie n .IP "$dirfile\->alter_encoding ($ENCODING, [$FRAGMENT_INDEX, $RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_encoding ($ENCODING, [$FRAGMENT_INDEX, \f(CW$RECODE\fR])" 4
.IX Item "$dirfile->alter_encoding ($ENCODING, [$FRAGMENT_INDEX, $RECODE])"
Both \f(CW$FRAGMENT_INDEX\fR and \f(CW$RECODE\fR default to 0 if not given.
.ie n .IP "$dirfile\->alter_endianness ($BYTE_SEX, [$FRAGMENT_INDEX, $RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_endianness ($BYTE_SEX, [$FRAGMENT_INDEX, \f(CW$RECODE\fR])" 4
.IX Item "$dirfile->alter_endianness ($BYTE_SEX, [$FRAGMENT_INDEX, $RECODE])"
Both \f(CW$FRAGMENT_INDEX\fR and \f(CW$RECODE\fR default to 0 if not given.
.ie n .IP "$dirfile\->alter_entry ($FIELD_CODE, $ENTRY, [$RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_entry ($FIELD_CODE, \f(CW$ENTRY\fR, [$RECODE])" 4
.IX Item "$dirfile->alter_entry ($FIELD_CODE, $ENTRY, [$RECODE])"
\&\f(CW$ENTRY\fR should be a reference to an entry hash; see \*(L"\s-1ENTRY HASHES\*(R"\s0 above.
If not given, \f(CW$RECODE\fR defaults to 0.
.ie n .IP "$dirfile\->alter_frameoffset ($OFFSET, [$FRAGMENT_INDEX, $RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_frameoffset ($OFFSET, [$FRAGMENT_INDEX, \f(CW$RECODE\fR])" 4
.IX Item "$dirfile->alter_frameoffset ($OFFSET, [$FRAGMENT_INDEX, $RECODE])"
Both \f(CW$FRAGMENT_INDEX\fR and \f(CW$RECODE\fR default to 0 if not given.
.ie n .IP "$dirfile\->alter_lincom ($FIELD_CODE, [$N_FIELDS, $IN_FIELDS, $M, $B])" 4
.el .IP "\f(CW$dirfile\fR\->alter_lincom ($FIELD_CODE, [$N_FIELDS, \f(CW$IN_FIELDS\fR, \f(CW$M\fR, \f(CW$B\fR])" 4
.IX Item "$dirfile->alter_lincom ($FIELD_CODE, [$N_FIELDS, $IN_FIELDS, $M, $B])"
Arguments not given or set to undef are not changed.
If given, \f(CW$IN_FIELDS\fR, \f(CW$M\fR, and \f(CW$B\fR should be references to arrays of the
appropriate length.
.ie n .IP "$dirfile\->alter_linterp ($FIELD_CODE, [$IN_FIELD, $TABLE, $RENAME_TABLE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_linterp ($FIELD_CODE, [$IN_FIELD, \f(CW$TABLE\fR, \f(CW$RENAME_TABLE\fR])" 4
.IX Item "$dirfile->alter_linterp ($FIELD_CODE, [$IN_FIELD, $TABLE, $RENAME_TABLE])"
Arguments not given or set to undef are not changed.
If not given, \f(CW$RENAME_TABLE\fR defaults to 0.
.ie n .IP "$dirfile\->alter_mplex ($FIELD_CODE, [$IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX])" 4
.el .IP "\f(CW$dirfile\fR\->alter_mplex ($FIELD_CODE, [$IN_FIELD, \f(CW$COUNT_FIELD\fR, \f(CW$COUNT_VAL\fR, \f(CW$COUNT_MAX\fR])" 4
.IX Item "$dirfile->alter_mplex ($FIELD_CODE, [$IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW$COUNT_VAL\fR or \f(CW$COUNT_MAX\fR are \-1, that parameter is not
chaged.
.ie n .IP "$dirfile\->alter_multiply ($FIELD_CODE, [$IN_FIELD1, $IN_FIELD2])" 4
.el .IP "\f(CW$dirfile\fR\->alter_multiply ($FIELD_CODE, [$IN_FIELD1, \f(CW$IN_FIELD2\fR])" 4
.IX Item "$dirfile->alter_multiply ($FIELD_CODE, [$IN_FIELD1, $IN_FIELD2])"
Arguments not given or set to undef are not changed.
.ie n .IP "$dirfile\->alter_phase ($FIELD_CODE, $IN_FIELD, $SHIFT)" 4
.el .IP "\f(CW$dirfile\fR\->alter_phase ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$SHIFT\fR)" 4
.IX Item "$dirfile->alter_phase ($FIELD_CODE, $IN_FIELD, $SHIFT)"
If \f(CW\*(C`$IN_FIELD == undef\*(C'\fR, it is not changed.
.ie n .IP "$dirfile\->alter_polynom ($FIELD_CODE, [$POLY_ORD, $IN_FIELD, $A])" 4
.el .IP "\f(CW$dirfile\fR\->alter_polynom ($FIELD_CODE, [$POLY_ORD, \f(CW$IN_FIELD\fR, \f(CW$A\fR])" 4
.IX Item "$dirfile->alter_polynom ($FIELD_CODE, [$POLY_ORD, $IN_FIELD, $A])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW\*(C`$POLY_ORD == 0\*(C'\fR, it is not changed.
.ie n .IP "$dirfile\->alter_protection ($PROTECTION_LEVEL, $FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->alter_protection ($PROTECTION_LEVEL, \f(CW$FRAGMENT_INDEX\fR)" 4
.IX Item "$dirfile->alter_protection ($PROTECTION_LEVEL, $FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->alter_raw ($FIELD_CODE, [$DATA_TYPE, $SPF, $RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_raw ($FIELD_CODE, [$DATA_TYPE, \f(CW$SPF\fR, \f(CW$RECODE\fR])" 4
.IX Item "$dirfile->alter_raw ($FIELD_CODE, [$DATA_TYPE, $SPF, $RECODE])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW\*(C`$DATA_TYPE == $GetData::NULL\*(C'\fR or \f(CW\*(C`$SPF == 0\*(C'\fR, that parameter
is not changed.
If not given, \f(CW$RECODE\fR defaults to 0.
.ie n .IP "$dirfile\->alter_recip ($FIELD_CODE, [$IN_FIELD, $DIVIDEND])" 4
.el .IP "\f(CW$dirfile\fR\->alter_recip ($FIELD_CODE, [$IN_FIELD, \f(CW$DIVIDEND\fR])" 4
.IX Item "$dirfile->alter_recip ($FIELD_CODE, [$IN_FIELD, $DIVIDEND])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW\*(C`$DIVIDEND == 0\*(C'\fR, it is not changed.
\&\f(CW$DIVIDEND\fR may be of any numerical type, including \f(CW\*(C`Math::Complex\*(C'\fR.
.ie n .IP "$dirfile\->alter_sbit ($FIELD_CODE, [$IN_FIELD, $BITNUM, $NUMBITS])" 4
.el .IP "\f(CW$dirfile\fR\->alter_sbit ($FIELD_CODE, [$IN_FIELD, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR])" 4
.IX Item "$dirfile->alter_sbit ($FIELD_CODE, [$IN_FIELD, $BITNUM, $NUMBITS])"
Arguments not given or set to undef are not changed.
Additionally, if \f(CW\*(C`$BITNUM == \-1\*(C'\fR, or \f(CW\*(C`$NUMBITS == 0\*(C'\fR, that parameter is not
changed.
.ie n .IP "$dirfile\->alter_spec ($LINE, [$RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->alter_spec ($LINE, [$RECODE])" 4
.IX Item "$dirfile->alter_spec ($LINE, [$RECODE])"
If not given, \f(CW$RECODE\fR defaults to 0.
.ie n .IP "$dirfile\->alter_window ($FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD)" 4
.el .IP "\f(CW$dirfile\fR\->alter_window ($FIELD_CODE, \f(CW$IN_FIELD\fR, \f(CW$CHECK_FIELD\fR, \f(CW$WINDOP\fR, \f(CW$THRESHOLD\fR)" 4
.IX Item "$dirfile->alter_window ($FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD)"
If \f(CW$IN_FIELD\fR or \f(CW$CHECK_FIELD\fR are undef, or if \f(CW\*(C`$WINDOP ==
$GetData::WINDOP_UNK\*(C'\fR, that paremeter is not changed. Otherwise,
\&\f(CW$WINDOP\fR should be one of the symbols listed under \*(L"\s-1WINDOW\s0 Operators\*(R" above.
.ie n .IP "$dirfile\->array_len ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->array_len ($FIELD_CODE)" 4
.IX Item "$dirfile->array_len ($FIELD_CODE)"

.ie n .IP "$dirfile\->bof ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->bof ($FIELD_CODE)" 4
.IX Item "$dirfile->bof ($FIELD_CODE)"

.ie n .IP "$dirfile\->delete ($FIELD_CODE, [$FLAGS])" 4
.el .IP "\f(CW$dirfile\fR\->delete ($FIELD_CODE, [$FLAGS])" 4
.IX Item "$dirfile->delete ($FIELD_CODE, [$FLAGS])"
If not given, \f(CW$FLAGS\fR defaults to 0.  Otherwise, it should be a bitwise or'd
collection of zero or more of the following flags:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::DEL_DATA\fR,
\&\f(CW$GetData::DEL_DEREF\fR,
\&\f(CW$GetData::DEL_FORCE\fR,
\&\f(CW$GetData::DEL_META\fR.
.RE
.RE
.RS 4
.RE
.ie n .IP "$dirfile\->desync ([$FLAGS])" 4
.el .IP "\f(CW$dirfile\fR\->desync ([$FLAGS])" 4
.IX Item "$dirfile->desync ([$FLAGS])"
If omitted, \f(CW$FLAGS\fR defaults to zero.  Otherwise, it should be zero or more
of the following flags bitwise or'd together:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::DESYNC_PATHCHECK\fR,
\&\f(CW$GetData::DESYNC_REOPEN\fR.
.RE
.RE
.RS 4
.RE
.ie n .IP "$dirfile\->dirfilename ()" 4
.el .IP "\f(CW$dirfile\fR\->dirfilename ()" 4
.IX Item "$dirfile->dirfilename ()"

.ie n .IP "$dirfile\->dirfile_standards ([$VERSION])" 4
.el .IP "\f(CW$dirfile\fR\->dirfile_standards ([$VERSION])" 4
.IX Item "$dirfile->dirfile_standards ([$VERSION])"
In addition to a simple integer verison number, \f(CW$VERSION\fR may be one of the
symbols
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::VERSION_CURRENT\fR,
\&\f(CW$GetData::VERSION_EARLIEST\fR,
\&\f(CW$GetData::VERSION_LATEST\fR.
.RE
.RE
.RS 4
.Sp
If not given, \f(CW$GetData::VERSION_CURRENT\fR is assumed.
.RE
.ie n .IP "$dirfile\->encoding ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->encoding ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->encoding ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->endianness ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->endianness ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->endianness ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->eof ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->eof ($FIELD_CODE)" 4
.IX Item "$dirfile->eof ($FIELD_CODE)"

.ie n .IP "$dirfile\->error_count ()" 4
.el .IP "\f(CW$dirfile\fR\->error_count ()" 4
.IX Item "$dirfile->error_count ()"

.ie n .IP "$dirfile\->flags ([$SET, $RESET])" 4
.el .IP "\f(CW$dirfile\fR\->flags ([$SET, \f(CW$RESET\fR])" 4
.IX Item "$dirfile->flags ([$SET, $RESET])"
If omitted, \f(CW$SET\fR and \f(CW$RESET\fR default to 0.  Otherwise, they should be
zero or more of the following flags, bitwise or'd together:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::PRETTY_PRINT\fR,
\&\f(CW$GetData::VERBOSE\fR.
.RE
.RE
.RS 4
.RE
.ie n .IP "$dirfile\->flush ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->flush ($FIELD_CODE)" 4
.IX Item "$dirfile->flush ($FIELD_CODE)"

.ie n .IP "$dirfile\->fragment_index ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->fragment_index ($FIELD_CODE)" 4
.IX Item "$dirfile->fragment_index ($FIELD_CODE)"

.ie n .IP "$dirfile\->fragmentname ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->fragmentname ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->fragmentname ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->frameoffset ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->frameoffset ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->frameoffset ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->framenum ($FIELD_CODE, $VALUE, [$START, $END])" 4
.el .IP "\f(CW$dirfile\fR\->framenum ($FIELD_CODE, \f(CW$VALUE\fR, [$START, \f(CW$END\fR])" 4
.IX Item "$dirfile->framenum ($FIELD_CODE, $VALUE, [$START, $END])"
\&\f(CW$START\fR and \f(CW$END\fR default to 0 if not given.
.ie n .IP "$dirfile\->hidden ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->hidden ($FIELD_CODE)" 4
.IX Item "$dirfile->hidden ($FIELD_CODE)"

.ie n .IP "$dirfile\->hide ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->hide ($FIELD_CODE)" 4
.IX Item "$dirfile->hide ($FIELD_CODE)"

.ie n .IP "$dirfile\->madd ($ENTRY, $PARENT)" 4
.el .IP "\f(CW$dirfile\fR\->madd ($ENTRY, \f(CW$PARENT\fR)" 4
.IX Item "$dirfile->madd ($ENTRY, $PARENT)"
\&\f(CW$ENTRY\fR should be a reference to an entry hash; see \*(L"\s-1ENTRY HASHES\*(R"\s0 above.
.ie n .IP "$dirfile\->madd_alias ($PARENT, $FIELD_CODE, $TARGET)" 4
.el .IP "\f(CW$dirfile\fR\->madd_alias ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$TARGET\fR)" 4
.IX Item "$dirfile->madd_alias ($PARENT, $FIELD_CODE, $TARGET)"

.ie n .IP "$dirfile\->madd_bit ($PARENT, $FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS)" 4
.el .IP "\f(CW$dirfile\fR\->madd_bit ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR)" 4
.IX Item "$dirfile->madd_bit ($PARENT, $FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS)"

.ie n .IP "$dirfile\->madd_divide ($PARENT, $FIELD_CODE, $IN_FIELD1, $IN_FIELD2)" 4
.el .IP "\f(CW$dirfile\fR\->madd_divide ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD1\fR, \f(CW$IN_FIELD2\fR)" 4
.IX Item "$dirfile->madd_divide ($PARENT, $FIELD_CODE, $IN_FIELD1, $IN_FIELD2)"

.ie n .IP "$dirfile\->madd_lincom ($PARENT, $FIELD_CODE, $N_FIELDS, $IN_FIELDS, $M, $B)" 4
.el .IP "\f(CW$dirfile\fR\->madd_lincom ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$N_FIELDS\fR, \f(CW$IN_FIELDS\fR, \f(CW$M\fR, \f(CW$B\fR)" 4
.IX Item "$dirfile->madd_lincom ($PARENT, $FIELD_CODE, $N_FIELDS, $IN_FIELDS, $M, $B)"
\&\f(CW$IN_FIELDS\fR, \f(CW$M\fR, and \f(CW$B\fR should be references to arrays of the
appropriate length.  The elements of \f(CW$M\fR and \f(CW$B\fR may be of any numerical
type, including \f(CW\*(C`Math::Complex\*(C'\fR.
.ie n .IP "$dirfile\->madd_linterp ($PARENT, $FIELD_CODE, $IN_FIELD, $TABLE)" 4
.el .IP "\f(CW$dirfile\fR\->madd_linterp ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$TABLE\fR)" 4
.IX Item "$dirfile->madd_linterp ($PARENT, $FIELD_CODE, $IN_FIELD, $TABLE)"

.ie n .IP "$dirfile\->madd_mplex ($PARENT, $FIELD_CODE, $IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX)" 4
.el .IP "\f(CW$dirfile\fR\->madd_mplex ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$COUNT_FIELD\fR, \f(CW$COUNT_VAL\fR, \f(CW$COUNT_MAX\fR)" 4
.IX Item "$dirfile->madd_mplex ($PARENT, $FIELD_CODE, $IN_FIELD, $COUNT_FIELD, $COUNT_VAL, $COUNT_MAX)"

.ie n .IP "$dirfile\->madd_multiply ($PARENT, $FIELD_CODE, $IN_FIELD1, $IN_FIELD2)" 4
.el .IP "\f(CW$dirfile\fR\->madd_multiply ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD1\fR, \f(CW$IN_FIELD2\fR)" 4
.IX Item "$dirfile->madd_multiply ($PARENT, $FIELD_CODE, $IN_FIELD1, $IN_FIELD2)"

.ie n .IP "$dirfile\->madd_phase ($PARENT, $FIELD_CODE, $IN_FIELD, $SHIFT)" 4
.el .IP "\f(CW$dirfile\fR\->madd_phase ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$SHIFT\fR)" 4
.IX Item "$dirfile->madd_phase ($PARENT, $FIELD_CODE, $IN_FIELD, $SHIFT)"

.ie n .IP "$dirfile\->madd_polynom ($PARENT, $FIELD_CODE, $POLY_ORD, $IN_FIELD, $A)" 4
.el .IP "\f(CW$dirfile\fR\->madd_polynom ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$POLY_ORD\fR, \f(CW$IN_FIELD\fR, \f(CW$A\fR)" 4
.IX Item "$dirfile->madd_polynom ($PARENT, $FIELD_CODE, $POLY_ORD, $IN_FIELD, $A)"
\&\f(CW$A\fR should be a reference to an array of numbers (of any numerical type,
including \f(CW\*(C`Math::Complex\*(C'\fR) of the appropriate length.
.ie n .IP "$dirfile\->madd_recip ($PARENT, $FIELD_CODE, $IN_FIELD, $DIVIDEND)" 4
.el .IP "\f(CW$dirfile\fR\->madd_recip ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$DIVIDEND\fR)" 4
.IX Item "$dirfile->madd_recip ($PARENT, $FIELD_CODE, $IN_FIELD, $DIVIDEND)"
\&\f(CW$DIVIDEND\fR may be of any numerical type, including \f(CW\*(C`Math::Complex\*(C'\fR.
.ie n .IP "$dirfile\->madd_sbit ($PARENT, $FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS)" 4
.el .IP "\f(CW$dirfile\fR\->madd_sbit ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$BITNUM\fR, \f(CW$NUMBITS\fR)" 4
.IX Item "$dirfile->madd_sbit ($PARENT, $FIELD_CODE, $IN_FIELD, $BITNUM, $NUMBITS)"

.ie n .IP "$dirfile\->madd_spec ($LINE, $PARENT)" 4
.el .IP "\f(CW$dirfile\fR\->madd_spec ($LINE, \f(CW$PARENT\fR)" 4
.IX Item "$dirfile->madd_spec ($LINE, $PARENT)"

.ie n .IP "$dirfile\->madd_string ($PARENT, $FIELD_CODE, $VALUE)" 4
.el .IP "\f(CW$dirfile\fR\->madd_string ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$VALUE\fR)" 4
.IX Item "$dirfile->madd_string ($PARENT, $FIELD_CODE, $VALUE)"

.ie n .IP "$dirfile\->madd_window ($PARENT, $FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD)" 4
.el .IP "\f(CW$dirfile\fR\->madd_window ($PARENT, \f(CW$FIELD_CODE\fR, \f(CW$IN_FIELD\fR, \f(CW$CHECK_FIELD\fR, \f(CW$WINDOP\fR, \f(CW$THRESHOLD\fR)" 4
.IX Item "$dirfile->madd_window ($PARENT, $FIELD_CODE, $IN_FIELD, $CHECK_FIELD, $WINDOP, $THRESHOLD)"
\&\f(CW$WINDOP\fR should be one of the symbols listed under \*(L"\s-1WINDOW\s0 Operators\*(R" above.
.ie n .IP "$dirfile\->malter_spec ($LINE, $PARENT, [$RECODE])" 4
.el .IP "\f(CW$dirfile\fR\->malter_spec ($LINE, \f(CW$PARENT\fR, [$RECODE])" 4
.IX Item "$dirfile->malter_spec ($LINE, $PARENT, [$RECODE])"
If not given, \f(CW$RECODE\fR defaults to 0.
.ie n .IP "$dirfile\->metaflush ()" 4
.el .IP "\f(CW$dirfile\fR\->metaflush ()" 4
.IX Item "$dirfile->metaflush ()"

.ie n .IP "$dirfile\->move ($FIELD_CODE, $NEW_FRAGMENT, [$MOVE_DATA])" 4
.el .IP "\f(CW$dirfile\fR\->move ($FIELD_CODE, \f(CW$NEW_FRAGMENT\fR, [$MOVE_DATA])" 4
.IX Item "$dirfile->move ($FIELD_CODE, $NEW_FRAGMENT, [$MOVE_DATA])"
If not given, \f(CW$FLAGS\fR defaults to 0.  Otherwise, it should be a bitwise or'd
collection of zero or more of the following flags:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::REN_DANGLE\fR,
\&\f(CW$GetData::REN_DATA\fR,
\&\f(CW$GetData::REN_FORCE\fR,
\&\f(CW$GetData::REN_UPDB\fR.
.RE
.RE
.RS 4
.RE
.ie n .IP "$dirfile\->mplex_lookback ($LOOKBACK)" 4
.el .IP "\f(CW$dirfile\fR\->mplex_lookback ($LOOKBACK)" 4
.IX Item "$dirfile->mplex_lookback ($LOOKBACK)"

.ie n .IP "$dirfile\->native_type ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->native_type ($FIELD_CODE)" 4
.IX Item "$dirfile->native_type ($FIELD_CODE)"
The returned value will be one of the symbols listed above under
\&\*(L"Data Types\*(R".
.ie n .IP "$dirfile\->nframes ()" 4
.el .IP "\f(CW$dirfile\fR\->nframes ()" 4
.IX Item "$dirfile->nframes ()"

.ie n .IP "$dirfile\->parent_fragment ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->parent_fragment ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->parent_fragment ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->protection ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->protection ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->protection ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->put_string ($FIELD_CODE, $STRING)" 4
.el .IP "\f(CW$dirfile\fR\->put_string ($FIELD_CODE, \f(CW$STRING\fR)" 4
.IX Item "$dirfile->put_string ($FIELD_CODE, $STRING)"

.ie n .IP "$dirfile\->raw_close ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->raw_close ($FIELD_CODE)" 4
.IX Item "$dirfile->raw_close ($FIELD_CODE)"

.ie n .IP "$dirfile\->raw_filename ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->raw_filename ($FIELD_CODE)" 4
.IX Item "$dirfile->raw_filename ($FIELD_CODE)"

.ie n .IP "$dirfile\->reference ([$FIELD_CODE])" 4
.el .IP "\f(CW$dirfile\fR\->reference ([$FIELD_CODE])" 4
.IX Item "$dirfile->reference ([$FIELD_CODE])"
If \f(CW$FIELD_CODE\fR is not given or undef, this function simply reports the
current reference field.
.ie n .IP "$dirfile\->rename ($OLD_CODE, $NEW_NAME, [$FLAGS])" 4
.el .IP "\f(CW$dirfile\fR\->rename ($OLD_CODE, \f(CW$NEW_NAME\fR, [$FLAGS])" 4
.IX Item "$dirfile->rename ($OLD_CODE, $NEW_NAME, [$FLAGS])"
If not given, \f(CW$FLAGS\fR defaults to 0.  Otherwise, it should be a bitwise or'd
collection of zero or more of the following flags:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::REN_DANGLE\fR,
\&\f(CW$GetData::REN_DATA\fR,
\&\f(CW$GetData::REN_FORCE\fR,
\&\f(CW$GetData::REN_UPDB\fR.
.RE
.RE
.RS 4
.RE
.ie n .IP "$dirfile\->rewrite_fragment ($FRAGMENT_INDEX)" 4
.el .IP "\f(CW$dirfile\fR\->rewrite_fragment ($FRAGMENT_INDEX)" 4
.IX Item "$dirfile->rewrite_fragment ($FRAGMENT_INDEX)"

.ie n .IP "$dirfile\->seek ($FIELD_CODE, $FRAME_NUM, $SAMPLE_NUM, [$FLAGS])" 4
.el .IP "\f(CW$dirfile\fR\->seek ($FIELD_CODE, \f(CW$FRAME_NUM\fR, \f(CW$SAMPLE_NUM\fR, [$FLAGS])" 4
.IX Item "$dirfile->seek ($FIELD_CODE, $FRAME_NUM, $SAMPLE_NUM, [$FLAGS])"
If not given, \f(CW$FLAGS\fR defaults to \f(CW$GetData::SEEK_SET\fR.  Otherwise, it should
be one of:
.RS 4
.Sp
.RS 4
\&\f(CW$GetData::SEEK_CUR\fR,
\&\f(CW$GetData::SEEK_END\fR,
\&\f(CW$GetData::SEEK_SET\fR.
.RE
.RE
.RS 4
.Sp
Furthermore, this value should be bitwise or'd with \f(CW$GetData::SEEK_WRITE\fR if
the next operation on the field is a write (via \*(L"putdata\*(R").
.RE
.ie n .IP "$dirfile\->spf ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->spf ($FIELD_CODE)" 4
.IX Item "$dirfile->spf ($FIELD_CODE)"

.ie n .IP "$dirfile\->sync ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->sync ($FIELD_CODE)" 4
.IX Item "$dirfile->sync ($FIELD_CODE)"

.ie n .IP "$dirfile\->tell ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->tell ($FIELD_CODE)" 4
.IX Item "$dirfile->tell ($FIELD_CODE)"

.ie n .IP "$dirfile\->unhide ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->unhide ($FIELD_CODE)" 4
.IX Item "$dirfile->unhide ($FIELD_CODE)"

.ie n .IP "$dirfile\->uninclude ($FRAGMENT_INDEX, [$DEL])" 4
.el .IP "\f(CW$dirfile\fR\->uninclude ($FRAGMENT_INDEX, [$DEL])" 4
.IX Item "$dirfile->uninclude ($FRAGMENT_INDEX, [$DEL])"
If not given, \f(CW$DEL\fR defaults to 0.
.ie n .IP "$dirfile\->validate ($FIELD_CODE)" 4
.el .IP "\f(CW$dirfile\fR\->validate ($FIELD_CODE)" 4
.IX Item "$dirfile->validate ($FIELD_CODE)"

.ie n .IP "$dirfile\->verbose_prefix ([$PREFIX])" 4
.el .IP "\f(CW$dirfile\fR\->verbose_prefix ([$PREFIX])" 4
.IX Item "$dirfile->verbose_prefix ([$PREFIX])"
If \f(CW$PREFIX\fR is omitted or undef, the prefix is removed.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2012\-2015 D. V. Wiebe
.PP
GetData is free software; you can redistribute it and/or modify it under the
terms of the \s-1GNU\s0 Lesser General Public License as published by the Free Software
Foundation: either version 2.1 of the License, or (at your option) any later
version.
.PP
GetData is distributed in the hope that it will be useful, but without any
warranty; without even the implied warranty of merchantability or fitness for
a particular purpose. See the \s-1GNU\s0 Lesser General Public License for more
details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIMath::Complex\fR\|(3), \fIdirfile\fR\|(5)
